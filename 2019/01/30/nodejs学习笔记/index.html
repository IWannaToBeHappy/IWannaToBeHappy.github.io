<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="网页,nodejs," />





  <link rel="alternate" href="/atom.xml" title="种菜园" type="application/atom+xml" />






<meta name="description" content="自学参考 http:&#x2F;&#x2F;www.runoob.com&#x2F;nodejs&#x2F;nodejs-tutorial.html 简介简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。Node.js是一个事件驱动I&#x2F;O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非">
<meta property="og:type" content="article">
<meta property="og:title" content="nodejs学习笔记">
<meta property="og:url" content="https://iwannatobehappy.github.io/2019/01/30/nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="种菜园">
<meta property="og:description" content="自学参考 http:&#x2F;&#x2F;www.runoob.com&#x2F;nodejs&#x2F;nodejs-tutorial.html 简介简单的说 Node.js 就是运行在服务端的 JavaScript。Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。Node.js是一个事件驱动I&#x2F;O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非">
<meta property="og:image" content="http://www.runoob.com/wp-content/uploads/2014/03/node-hello.gif">
<meta property="og:image" content="http://www.runoob.com/wp-content/uploads/2015/09/event_loop.jpg">
<meta property="og:image" content="http://www.runoob.com/wp-content/uploads/2014/04/227B22AE-E633-4DCB-8740-AA51D32B8942.jpg">
<meta property="og:image" content="http://www.runoob.com/wp-content/uploads/2014/06/4A1C02B2-2EB8-4976-9F35-F3760713D495.jpg">
<meta property="og:image" content="http://www.runoob.com/wp-content/uploads/2014/06/ADF34B0E-6715-41EE-9A88-4BE067100868.jpg">
<meta property="og:image" content="http://www.runoob.com/wp-content/uploads/2014/06/nodepost.gif">
<meta property="og:image" content="http://www.runoob.com/wp-content/uploads/2015/09/6E0D2A5C-0339-4D61-858D-A4EEB5763D98.jpg">
<meta property="article:published_time" content="2019-01-30T02:02:53.000Z">
<meta property="article:modified_time" content="2019-02-18T06:04:24.301Z">
<meta property="article:author" content="陈潇">
<meta property="article:tag" content="网页">
<meta property="article:tag" content="nodejs">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://www.runoob.com/wp-content/uploads/2014/03/node-hello.gif">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://iwannatobehappy.github.io/2019/01/30/nodejs学习笔记/"/>





  <title>nodejs学习笔记 | 种菜园</title>
  








<meta name="generator" content="Hexo 4.2.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">种菜园</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-random">
          <a href="/random.html" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            random
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://iwannatobehappy.github.io/2019/01/30/nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="陈潇">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="种菜园">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">nodejs学习笔记</h1>
        

        <div class="post-meta">
          <span class="post-time">
		  
		  
		  
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-30T10:02:53+08:00">
                2019-01-30
              </time>
            

            

            
          </span>

          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2019/01/30/nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count valine-comment-count" data-xid="/2019/01/30/nodejs%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-eye"></i>
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  26.7k
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>自学参考 <a href="http://www.runoob.com/nodejs/nodejs-tutorial.html" target="_blank" rel="noopener">http://www.runoob.com/nodejs/nodejs-tutorial.html</a></p>
<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>简单的说 Node.js 就是运行在服务端的 JavaScript。<br>Node.js 是一个基于Chrome JavaScript 运行时建立的一个平台。<br>Node.js是一个事件驱动I/O服务端JavaScript环境，基于Google的V8引擎，V8引擎执行Javascript的速度非常快，性能非常好。</p>
<a id="more"></a>
<hr>
<h1 id="大览"><a href="#大览" class="headerlink" title="大览"></a>大览</h1><p>nodejs通常由3个部分组成：</p>
<ol>
<li><strong>引入required模块：</strong>使用require指令载入Node.js模块</li>
<li><strong>创建服务器：</strong>服务器可以监听客户端的请求</li>
<li><strong>接收和响应请求：</strong>服务器创建后，客户端通过浏览器或终端发送HTTP请求，服务器接收请求后返回响应数据</li>
</ol>
<h2 id="helloworld"><a href="#helloworld" class="headerlink" title="helloworld"></a>helloworld</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&#39;http&#39;);</span><br><span class="line"></span><br><span class="line">http.createServer(function (request, response) &#123;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 发送 HTTP 头部 </span><br><span class="line">    &#x2F;&#x2F; HTTP 状态值: 200 : OK</span><br><span class="line">    &#x2F;&#x2F; 内容类型: text&#x2F;plain</span><br><span class="line">    response.writeHead(200, &#123;&#39;Content-Type&#39;: &#39;text&#x2F;plain&#39;&#125;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; 发送响应数据 &quot;Hello World&quot;</span><br><span class="line">    response.end(&#39;Hello World\n&#39;);</span><br><span class="line">&#125;).listen(8888);</span><br><span class="line">&#x2F;&#x2F; createServer 函数会返回一个对象，这个对象有一个叫做 listen 的方法，这个方法有一个数值参数， 指定这个 HTTP 服务器监听的端口号。</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 终端打印如下信息</span><br><span class="line">console.log(&#39;Server running at http:&#x2F;&#x2F;127.0.0.1:8888&#x2F;&#39;);</span><br></pre></td></tr></table></figure>
<p>代码运行演示如下：<br> <img src="http://www.runoob.com/wp-content/uploads/2014/03/node-hello.gif" alt="helloworld"></p>
<hr>
<h1 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h1><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>为了让Node.js的文件可以相互调用，Node.js提供了一个简单的模块系统。<br>模块是Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个 Node.js 文件就是一个模块，这个文件可能是JavaScript 代码、JSON 或者编译过的C/C++ 扩展。</p>
<h2 id="NPM-包管理工具"><a href="#NPM-包管理工具" class="headerlink" title="NPM 包管理工具"></a>NPM 包管理工具</h2><p>NPM是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种：</p>
<ul>
<li>允许用户从NPM服务器下载别人编写的第三方包到本地使用。</li>
<li>允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。</li>
<li>允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。</li>
</ul>
<p>npm自身更新命令：<br><code>$ sudo npm install npm -g</code>-Unix<br><code>npm install npm -g</code>-Window<br><code>cnpm install npm -g</code>-Window 淘宝镜像</p>
<p>使用npm管理模块：</p>
<ul>
<li><strong>本地安装</strong> ： <code>npm install &lt;Moudle Name&gt;</code><br>安装好后包存放于当前目录下的 node_modules 目录中，因此在代码中只需要通过 require 方式就好，无需指定第三方包路径。如：<code>var express = require(&#39;express&#39;);</code></li>
<li><strong>全局安装</strong>： <code>npm install &lt;Moudle Name&gt; -g</code><br>安装好后包存放于 /usr/local 下或者你 node 的安装目录，在代码中同样只需要通过 require 方式就好，无需指定第三方包路径。</li>
<li><strong>卸载模块</strong> ： <code>npm uninstall &lt;Moudle Name&gt;</code></li>
<li><strong>更新模块</strong> : <code>npm update &lt;Moudle Name&gt;</code></li>
<li><strong>搜索模块</strong> : <code>npm search &lt;Moudle Name&gt;</code></li>
<li><strong>创建模块</strong> : 如果你想创建自己的模块以及发布模块，可以参照以下代码初始化包，创建时自动要求输入包属性生成package.json文件<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ npm init</span><br><span class="line">This utility will walk you through creating a package.json file.</span><br><span class="line">It only covers the most common items, and tries to guess sensible defaults.</span><br><span class="line"></span><br><span class="line">See &#96;npm help json&#96; for definitive documentation on these fields</span><br><span class="line">and exactly what they do.</span><br><span class="line"></span><br><span class="line">Use &#96;npm install &lt;pkg&gt; --save&#96; afterwards to install a package and</span><br><span class="line">save it as a dependency in the package.json file.</span><br><span class="line"></span><br><span class="line">Press ^C at any time to quit.</span><br><span class="line">name: (node_modules) runoob                   # 模块名</span><br><span class="line">version: (1.0.0) </span><br><span class="line">description: Node.js 测试模块(www.runoob.com)  # 描述</span><br><span class="line">entry point: (index.js) </span><br><span class="line">test command: make test</span><br><span class="line">git repository: https:&#x2F;&#x2F;github.com&#x2F;runoob&#x2F;runoob.git  # Github 地址</span><br><span class="line">keywords: </span><br><span class="line">author: </span><br><span class="line">license: (ISC) </span><br><span class="line">About to write to ……&#x2F;node_modules&#x2F;package.json:      # 生成地址</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;runoob&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Node.js 测试模块(www.runoob.com)&quot;,</span><br><span class="line">  ……</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Is this ok? (yes) yes</span><br></pre></td></tr></table></figure>
接下来我们可以使用以下命令在 npm 资源库中注册用户（使用邮箱注册）:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ npm adduser</span><br><span class="line">Username: mcmohd</span><br><span class="line">Password:</span><br><span class="line">Email: (this IS public) mcmohd@gmail.com</span><br></pre></td></tr></table></figure>
接下来我们就用以下命令来发布模块：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm publish</span><br></pre></td></tr></table></figure>
如果你以上的步骤都操作正确，你就可以跟其他模块一样使用 npm 来安装。</li>
</ul>
<h3 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h3><p>除了可以在<a href="https://npmjs.org/doc/" target="_blank" rel="noopener">npmjs.org/doc/</a>查看官方文档外，这里再介绍一些NPM常用命令。<br>NPM提供了很多命令，例如install和publish，使用npm help可查看所有命令。</p>
<ul>
<li>使用npm help <command>可查看某条命令的详细帮助，例如npm help install。</li>
<li>在package.json所在目录下使用npm install . -g可先在本地安装当前命令行程序，可用于发布前的本地测试。</li>
<li>使用npm update <package>可以把当前目录下node_modules子目录里边的对应模块更新至最新版本。</li>
<li>使用npm update <package> -g可以把全局安装的对应命令行程序更新至最新版。</li>
<li>使用npm cache clear可以清空NPM本地缓存，用于对付使用相同版本号发布新版本代码的人。</li>
<li>使用npm unpublish <package>@<version>可以撤销发布自己发布过的某个版本代码。</li>
</ul>
<h3 id="淘宝-NPM-镜像"><a href="#淘宝-NPM-镜像" class="headerlink" title="淘宝 NPM 镜像"></a>淘宝 NPM 镜像</h3><p>大家都知道国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。<br>淘宝 NPM 镜像是一个完整 npmjs.org 镜像，你可以用此代替官方版本(只读)，同步频率目前为 10分钟 一次以保证尽量与官方服务同步。<br>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:<br><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code><br>这样就可以使用 cnpm 命令来安装模块了：<br><code>$ cnpm install [name]</code><br>更多信息可以查阅：<a href="http://npm.taobao.org/" target="_blank" rel="noopener">http://npm.taobao.org/</a>。</p>
<h2 id="package-json"><a href="#package-json" class="headerlink" title="package.json"></a>package.json</h2><p>在模块中，package.json定义了包的属性，例如，express包中的package.json文件内容为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;express&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;Fast, unopinionated, minimalist web framework&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;4.13.3&quot;,</span><br><span class="line">  &quot;author&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;TJ Holowaychuk&quot;,</span><br><span class="line">    &quot;email&quot;: &quot;tj@vision-media.ca&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;contributors&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Aaron Heckmann&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;aaron.heckmann+github@gmail.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Ciaran Jessup&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;ciaranj@gmail.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Douglas Christopher Wilson&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;doug@somethingdoug.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Guillermo Rauch&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;rauchg@gmail.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Jonathan Ong&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;me@jongleberry.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Roman Shtylman&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;shtylman+expressjs@gmail.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;Young Jae Sim&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;hanul@hanul.me&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;license&quot;: &quot;MIT&quot;,</span><br><span class="line">  &quot;repository&quot;: &#123;</span><br><span class="line">    &quot;type&quot;: &quot;git&quot;,</span><br><span class="line">    &quot;url&quot;: &quot;git+https:&#x2F;&#x2F;github.com&#x2F;strongloop&#x2F;express.git&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;homepage&quot;: &quot;http:&#x2F;&#x2F;expressjs.com&#x2F;&quot;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;express&quot;,</span><br><span class="line">    &quot;framework&quot;,</span><br><span class="line">    &quot;sinatra&quot;,</span><br><span class="line">    &quot;web&quot;,</span><br><span class="line">    &quot;rest&quot;,</span><br><span class="line">    &quot;restful&quot;,</span><br><span class="line">    &quot;router&quot;,</span><br><span class="line">    &quot;app&quot;,</span><br><span class="line">    &quot;api&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;dependencies&quot;: &#123;</span><br><span class="line">    &quot;accepts&quot;: &quot;~1.2.12&quot;,</span><br><span class="line">    &quot;array-flatten&quot;: &quot;1.1.1&quot;,</span><br><span class="line">    &quot;content-disposition&quot;: &quot;0.5.0&quot;,</span><br><span class="line">    &quot;content-type&quot;: &quot;~1.0.1&quot;,</span><br><span class="line">    &quot;cookie&quot;: &quot;0.1.3&quot;,</span><br><span class="line">    &quot;cookie-signature&quot;: &quot;1.0.6&quot;,</span><br><span class="line">    &quot;debug&quot;: &quot;~2.2.0&quot;,</span><br><span class="line">    &quot;depd&quot;: &quot;~1.0.1&quot;,</span><br><span class="line">    &quot;escape-html&quot;: &quot;1.0.2&quot;,</span><br><span class="line">    &quot;etag&quot;: &quot;~1.7.0&quot;,</span><br><span class="line">    &quot;finalhandler&quot;: &quot;0.4.0&quot;,</span><br><span class="line">    &quot;fresh&quot;: &quot;0.3.0&quot;,</span><br><span class="line">    &quot;merge-descriptors&quot;: &quot;1.0.0&quot;,</span><br><span class="line">    &quot;methods&quot;: &quot;~1.1.1&quot;,</span><br><span class="line">    &quot;on-finished&quot;: &quot;~2.3.0&quot;,</span><br><span class="line">    &quot;parseurl&quot;: &quot;~1.3.0&quot;,</span><br><span class="line">    &quot;path-to-regexp&quot;: &quot;0.1.7&quot;,</span><br><span class="line">    &quot;proxy-addr&quot;: &quot;~1.0.8&quot;,</span><br><span class="line">    &quot;qs&quot;: &quot;4.0.0&quot;,</span><br><span class="line">    &quot;range-parser&quot;: &quot;~1.0.2&quot;,</span><br><span class="line">    &quot;send&quot;: &quot;0.13.0&quot;,</span><br><span class="line">    &quot;serve-static&quot;: &quot;~1.10.0&quot;,</span><br><span class="line">    &quot;type-is&quot;: &quot;~1.6.6&quot;,</span><br><span class="line">    &quot;utils-merge&quot;: &quot;1.0.0&quot;,</span><br><span class="line">    &quot;vary&quot;: &quot;~1.0.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;after&quot;: &quot;0.8.1&quot;,</span><br><span class="line">    &quot;ejs&quot;: &quot;2.3.3&quot;,</span><br><span class="line">    &quot;istanbul&quot;: &quot;0.3.17&quot;,</span><br><span class="line">    &quot;marked&quot;: &quot;0.3.5&quot;,</span><br><span class="line">    &quot;mocha&quot;: &quot;2.2.5&quot;,</span><br><span class="line">    &quot;should&quot;: &quot;7.0.2&quot;,</span><br><span class="line">    &quot;supertest&quot;: &quot;1.0.1&quot;,</span><br><span class="line">    &quot;body-parser&quot;: &quot;~1.13.3&quot;,</span><br><span class="line">    &quot;connect-redis&quot;: &quot;~2.4.1&quot;,</span><br><span class="line">    &quot;cookie-parser&quot;: &quot;~1.3.5&quot;,</span><br><span class="line">    &quot;cookie-session&quot;: &quot;~1.2.0&quot;,</span><br><span class="line">    &quot;express-session&quot;: &quot;~1.11.3&quot;,</span><br><span class="line">    &quot;jade&quot;: &quot;~1.11.0&quot;,</span><br><span class="line">    &quot;method-override&quot;: &quot;~2.3.5&quot;,</span><br><span class="line">    &quot;morgan&quot;: &quot;~1.6.1&quot;,</span><br><span class="line">    &quot;multiparty&quot;: &quot;~4.1.2&quot;,</span><br><span class="line">    &quot;vhost&quot;: &quot;~3.0.1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;engines&quot;: &#123;</span><br><span class="line">    &quot;node&quot;: &quot;&gt;&#x3D; 0.10.0&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;files&quot;: [</span><br><span class="line">    &quot;LICENSE&quot;,</span><br><span class="line">    &quot;History.md&quot;,</span><br><span class="line">    &quot;Readme.md&quot;,</span><br><span class="line">    &quot;index.js&quot;,</span><br><span class="line">    &quot;lib&#x2F;&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;mocha --require test&#x2F;support&#x2F;env --reporter spec --bail --check-leaks test&#x2F; test&#x2F;acceptance&#x2F;&quot;,</span><br><span class="line">    &quot;test-ci&quot;: &quot;istanbul cover node_modules&#x2F;mocha&#x2F;bin&#x2F;_mocha --report lcovonly -- --require test&#x2F;support&#x2F;env --reporter spec --check-leaks test&#x2F; test&#x2F;acceptance&#x2F;&quot;,</span><br><span class="line">    &quot;test-cov&quot;: &quot;istanbul cover node_modules&#x2F;mocha&#x2F;bin&#x2F;_mocha -- --require test&#x2F;support&#x2F;env --reporter dot --check-leaks test&#x2F; test&#x2F;acceptance&#x2F;&quot;,</span><br><span class="line">    &quot;test-tap&quot;: &quot;mocha --require test&#x2F;support&#x2F;env --reporter tap --check-leaks test&#x2F; test&#x2F;acceptance&#x2F;&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;gitHead&quot;: &quot;ef7ad681b245fba023843ce94f6bcb8e275bbb8e&quot;,</span><br><span class="line">  &quot;bugs&quot;: &#123;</span><br><span class="line">    &quot;url&quot;: &quot;https:&#x2F;&#x2F;github.com&#x2F;strongloop&#x2F;express&#x2F;issues&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;_id&quot;: &quot;express@4.13.3&quot;,</span><br><span class="line">  &quot;_shasum&quot;: &quot;ddb2f1fb4502bf33598d2b032b037960ca6c80a3&quot;,</span><br><span class="line">  &quot;_from&quot;: &quot;express@*&quot;,</span><br><span class="line">  &quot;_npmVersion&quot;: &quot;1.4.28&quot;,</span><br><span class="line">  &quot;_npmUser&quot;: &#123;</span><br><span class="line">    &quot;name&quot;: &quot;dougwilson&quot;,</span><br><span class="line">    &quot;email&quot;: &quot;doug@somethingdoug.com&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;maintainers&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;tjholowaychuk&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;tj@vision-media.ca&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;jongleberry&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;jonathanrichardong@gmail.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;dougwilson&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;doug@somethingdoug.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;rfeng&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;enjoyjava@gmail.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;aredridel&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;aredridel@dinhe.net&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;strongloop&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;callback@strongloop.com&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;name&quot;: &quot;defunctzombie&quot;,</span><br><span class="line">      &quot;email&quot;: &quot;shtylman@gmail.com&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;dist&quot;: &#123;</span><br><span class="line">    &quot;shasum&quot;: &quot;ddb2f1fb4502bf33598d2b032b037960ca6c80a3&quot;,</span><br><span class="line">    &quot;tarball&quot;: &quot;http:&#x2F;&#x2F;registry.npmjs.org&#x2F;express&#x2F;-&#x2F;express-4.13.3.tgz&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;directories&quot;: &#123;&#125;,</span><br><span class="line">  &quot;_resolved&quot;: &quot;https:&#x2F;&#x2F;registry.npmjs.org&#x2F;express&#x2F;-&#x2F;express-4.13.3.tgz&quot;,</span><br><span class="line">  &quot;readme&quot;: &quot;ERROR: No README data found!&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中较为固定的属性有：</p>
<ul>
<li><strong>name</strong> - 包名。</li>
<li><strong>version</strong> - 包的版本号。</li>
<li><strong>description</strong> - 包的描述。</li>
<li><strong>homepage</strong> - 包的官网 url 。</li>
<li><strong>author</strong> - 包的作者姓名。</li>
<li><strong>contributors</strong> - 包的其他贡献者姓名。</li>
<li><strong>dependencies</strong> - 依赖包列表。如果依赖包没有安装，npm 会自动将依赖包安装在 node_module 目录下。</li>
<li><strong>repository</strong> - 包代码存放的地方的类型，可以是 git 或 svn，git 可在 Github 上。</li>
<li><strong>main</strong> - main 字段指定了程序的主入口文件，require(‘moduleName’) 就会加载这个文件。这个字段的默认值是模块根目录下面的 index.js。</li>
<li><strong>keywords</strong> - 关键字</li>
</ul>
<h3 id="版本号解释"><a href="#版本号解释" class="headerlink" title="版本号解释"></a>版本号解释</h3><p>使用NPM下载和发布代码时都会接触到版本号。NPM使用语义版本号来管理代码，这里简单介绍一下。<br>语义版本号分为X.Y.Z三位，分别代表主版本号、次版本号和补丁版本号。当代码变更时，版本号按以下原则更新。</p>
<ul>
<li>如果只是修复bug，需要更新Z位。</li>
<li>如果是新增了功能，但是向下兼容，需要更新Y位。</li>
<li>如果有大变动，向下不兼容，需要更新X位。</li>
</ul>
<p>版本号有了这个保证后，在申明第三方包依赖时，除了可依赖于一个固定版本号外，还可依赖于某个范围的版本号。例如”argv”: “0.0.x”表示依赖于0.0.x系列的最新版argv。<br>NPM支持的所有版本号范围指定方式可以查看<a href="https://npmjs.org/doc/files/package.json.html#dependencies" target="_blank" rel="noopener">官方文档</a>。</p>
<h2 id="创建模块"><a href="#创建模块" class="headerlink" title="创建模块"></a>创建模块</h2><p>在 Node.js 中，创建一个模块非常简单，如下我们创建一个 main.js 文件，代码如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var hello &#x3D; require(&#39;.&#x2F;hello&#39;);</span><br><span class="line">hello.world();</span><br></pre></td></tr></table></figure>
<p>以上实例中，代码 require(‘./hello’) 引入了当前目录下的 hello.js 文件（./ 为当前目录，node.js 默认后缀为 js）。<br>Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口，require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。<br>接下来我们就来创建 hello.js 文件，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">exports.world &#x3D; function() &#123;</span><br><span class="line">  console.log(&#39;Hello World&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在以上示例中，hello.js 通过 exports 对象把 world 作为模块的访问接口，在 main.js 中通过 require(‘./hello’) 加载这个模块，然后就可以直接访 问 hello.js 中 exports 对象的成员函数了。<br>有时候我们只是想把一个对象封装到模块中，格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">module.exports &#x3D; function() &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;hello.js </span><br><span class="line">function Hello() &#123; </span><br><span class="line">    var name; </span><br><span class="line">    this.setName &#x3D; function(thyName) &#123; </span><br><span class="line">        name &#x3D; thyName; </span><br><span class="line">    &#125;; </span><br><span class="line">    this.sayHello &#x3D; function() &#123; </span><br><span class="line">        console.log(&#39;Hello &#39; + name); </span><br><span class="line">    &#125;; </span><br><span class="line">&#125;; </span><br><span class="line">module.exports &#x3D; Hello;</span><br></pre></td></tr></table></figure>
<p>这样就可以直接获得这个对象了：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;main.js </span><br><span class="line">var Hello &#x3D; require(&#39;.&#x2F;hello&#39;); </span><br><span class="line">hello &#x3D; new Hello(); </span><br><span class="line">hello.setName(&#39;BYVoid&#39;); </span><br><span class="line">hello.sayHello();</span><br></pre></td></tr></table></figure>
<p>模块接口的唯一变化是使用 module.exports = Hello 代替了exports.world = function(){}。 在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的 exports。</p>
<hr>
<h1 id="Node-js-REPL-交互式解释器"><a href="#Node-js-REPL-交互式解释器" class="headerlink" title="Node.js REPL(交互式解释器)"></a>Node.js REPL(交互式解释器)</h1><p>Node.js REPL(Read Eval Print Loop:交互式解释器) 表示一个电脑的环境，类似 Window 系统的终端或 Unix/Linux shell，我们可以在终端中输入命令，并接收系统的响应。<br>Node 自带了交互式解释器，可以执行以下任务：</p>
<ul>
<li><strong>读取</strong> - 读取用户输入，解析输入了Javascript 数据结构并存储在内存中。</li>
<li><strong>执行</strong> - 执行输入的数据结构</li>
<li><strong>打印</strong> - 输出结果</li>
<li><strong>循环</strong> - 循环操作以上步骤直到用户两次按下 ctrl-c 按钮退出。<br>Node 的交互式解释器可以很好的调试 Javascript 代码。<br>开始学习 REPL<br>我们可以输入以下命令来启动 Node 的终端：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br></pre></td></tr></table></figure>
这时我们就可以在 &gt; 后输入简单的表达式，并按下回车键来计算结果。<h2 id="简单的表达式运算"><a href="#简单的表达式运算" class="headerlink" title="简单的表达式运算"></a>简单的表达式运算</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; 1 +4</span><br><span class="line">5</span><br><span class="line">&gt; 5 &#x2F; 2</span><br><span class="line">2.5</span><br><span class="line">&gt; 3 * 6</span><br><span class="line">18</span><br><span class="line">&gt; 4 - 1</span><br><span class="line">3</span><br><span class="line">&gt; 1 + ( 2 * 3 ) - 4</span><br><span class="line">3</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; x &#x3D; 10</span><br><span class="line">10</span><br><span class="line">&gt; var y &#x3D; 10</span><br><span class="line">undefined</span><br><span class="line">&gt; x + y</span><br><span class="line">20</span><br><span class="line">&gt; console.log(&quot;Hello World&quot;)</span><br><span class="line">Hello World</span><br><span class="line">undefined</span><br><span class="line">&gt; console.log(&quot;www.runoob.com&quot;)</span><br><span class="line">www.runoob.com</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>
<h2 id="多行表达式"><a href="#多行表达式" class="headerlink" title="多行表达式"></a>多行表达式</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; var x &#x3D; 0</span><br><span class="line">undefined</span><br><span class="line">&gt; do &#123;</span><br><span class="line">... x++;</span><br><span class="line">... console.log(&quot;x: &quot; + x);</span><br><span class="line">... &#125; while ( x &lt; 5 );</span><br><span class="line">x: 1</span><br><span class="line">x: 2</span><br><span class="line">x: 3</span><br><span class="line">x: 4</span><br><span class="line">x: 5</span><br><span class="line">undefined</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
… 三个点的符号是系统自动生成的，你回车换行后即可。Node 会自动检测是否为连续的表达式。<h2 id="下划线-变量"><a href="#下划线-变量" class="headerlink" title="下划线(_)变量"></a>下划线(_)变量</h2>你可以使用下划线(_)获取上一个表达式的运算结果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ node</span><br><span class="line">&gt; var x &#x3D; 10</span><br><span class="line">undefined</span><br><span class="line">&gt; var y &#x3D; 20</span><br><span class="line">undefined</span><br><span class="line">&gt; x + y</span><br><span class="line">30</span><br><span class="line">&gt; var sum &#x3D; _</span><br><span class="line">undefined</span><br><span class="line">&gt; console.log(sum)</span><br><span class="line">30</span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="REPL-命令"><a href="#REPL-命令" class="headerlink" title="REPL 命令"></a>REPL 命令</h2><ul>
<li><strong>ctrl + c</strong> - 退出当前终端。</li>
<li><strong>ctrl + c</strong> 按下两次 - 退出 Node REPL。</li>
<li><strong>ctrl + d</strong> - 退出 Node REPL.</li>
<li><strong>向上/向下键</strong> - 查看输入的历史命令</li>
<li><strong>tab 键</strong> - 列出当前命令</li>
<li><strong>.help</strong> - 列出使用命令</li>
<li><strong>.break</strong> - 退出多行表达式</li>
<li><strong>.clear</strong> - 退出多行表达式</li>
<li><strong>.save filename</strong> - 保存当前的 Node REPL 会话到指定文件</li>
<li><strong>.load filename</strong> - 载入当前 Node REPL 会话的文件内容。</li>
</ul>
<hr>
<h1 id="Node-js-回调函数"><a href="#Node-js-回调函数" class="headerlink" title="Node.js 回调函数"></a>Node.js 回调函数</h1><h2 id="异步与非阻塞"><a href="#异步与非阻塞" class="headerlink" title="异步与非阻塞"></a>异步与非阻塞</h2><p>阻塞和非阻塞，同步和异步是node.js里经常遇到的词汇，我举个简单的例子来说明：<br>我要看足球比赛，但是妈妈叫我烧水，电视机在客厅，烧水要在厨房。家里有2个水壶，一个是普通的水壶，另一个是水开了会叫的那种水壶。我可以：</p>
<ul>
<li>用普通的水壶烧，人在边上看着，水开了再去看球。（同步，阻塞）这个是常规做法，但是我看球不爽了。</li>
<li>用普通水壶烧，人去看球，隔几分钟去厨房看看。（同步，非阻塞）这个又大问题，万一在我离开的几分钟水开了，我就麻烦了。</li>
<li>用会叫的水壶，人在边上看着。（异步，阻塞）这个没有问题，但是我太傻了。</li>
<li>用会叫的水壶，人去看球，听见水壶叫了再去看。（异步，非阻塞）这个应该是最好的。<br>等着看球的我：阻塞<br>看着电视的我：非阻塞<br>普通水壶：同步<br>会叫的水壶：异步<br>所以，异步往往配合非阻塞，才能发挥出威力。</li>
</ul>
<p><strong>同步</strong>：同步就是你要做的事你列了一个清单，按照清单上的顺序 一个一个执行<br><strong>异步</strong>：就是可以同时干好几件事<br><strong>阻塞</strong>：就是按照清单上的顺序一件一件的往下走，当一件事没有做完，下面的事都干不了<br><strong>非阻塞</strong>：就是这件事没有干完，后面的事不会等你这件事干完了再干，而是直接开始干下一件事，等你这件事干完了，后面的事也干完了，这样就大大提高了效率</p>
<h2 id="node-js-回调函数"><a href="#node-js-回调函数" class="headerlink" title="node.js 回调函数"></a>node.js 回调函数</h2><p>Node.js 异步编程的直接体现就是回调。<br>异步编程依托于回调来实现，但不能说使用了回调后程序就异步化了。<br>回调函数在完成任务后就会被调用，Node 使用了大量的回调函数，Node 所有 API 都支持回调函数。<br>例如，我们可以一边读取文件，一边执行其他命令，在文件读取完成后，我们将文件内容作为回调函数的参数返回。这样在执行代码时就没有阻塞或等待文件 I/O 操作。这就大大提高了 Node.js 的性能，可以处理大量的并发请求。<br>回调函数一般作为函数的最后一个参数出现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function foo1(name, age, callback) &#123; &#125;</span><br><span class="line">function foo2(value, callback1, callback2) &#123; &#125;</span><br></pre></td></tr></table></figure>
<h2 id="阻塞代码实例"><a href="#阻塞代码实例" class="headerlink" title="阻塞代码实例"></a>阻塞代码实例</h2><p>创建一个文件 input.txt ，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">菜鸟教程官网地址：www.runoob.com</span><br></pre></td></tr></table></figure>
<p>创建 main.js 文件, 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">var data &#x3D; fs.readFileSync(&#39;input.txt&#39;);</span><br><span class="line"></span><br><span class="line">console.log(data.toString());</span><br><span class="line">console.log(&quot;程序执行结束!&quot;);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">菜鸟教程官网地址：www.runoob.com</span><br><span class="line"></span><br><span class="line">程序执行结束!</span><br></pre></td></tr></table></figure>

<h2 id="非阻塞代码实例"><a href="#非阻塞代码实例" class="headerlink" title="非阻塞代码实例"></a>非阻塞代码实例</h2><p>创建一个文件 input.txt ，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">菜鸟教程官网地址：www.runoob.com</span><br></pre></td></tr></table></figure>
<p>创建 main.js 文件, 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&#39;input.txt&#39;, function (err, data) &#123;</span><br><span class="line">    if (err) return console.error(err);</span><br><span class="line">    console.log(data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;程序执行结束!&quot;);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">程序执行结束!</span><br><span class="line">菜鸟教程官网地址：www.runoob.com</span><br></pre></td></tr></table></figure>
<p>以上两个实例我们了解了阻塞与非阻塞调用的不同。第一个实例在文件读取完后才执行完程序。 第二个实例我们不需要等待文件读取完，这样就可以在读取文件时同时执行接下来的代码，大大提高了程序的性能。<br>因此，阻塞是按顺序执行的，而非阻塞是不需要按顺序的，所以如果需要处理回调函数的参数，我们就需要写在回调函数内。</p>
<hr>
<h1 id="Node-js-事件循环"><a href="#Node-js-事件循环" class="headerlink" title="Node.js 事件循环"></a>Node.js 事件循环</h1><p>Node.js 是单进程单线程应用程序，但是因为 V8 引擎提供的异步执行回调接口，通过这些接口可以处理大量的并发，所以性能非常高。<br>Node.js 几乎每一个 API 都是支持回调函数的。<br>Node.js 基本上所有的事件机制都是用设计模式中观察者模式实现。<br>Node.js 单线程类似进入一个while(true)的事件循环，直到没有事件观察者退出，每个异步事件都生成一个事件观察者，如果有事件发生就调用该回调函数.</p>
<h2 id="事件驱动程序"><a href="#事件驱动程序" class="headerlink" title="事件驱动程序"></a>事件驱动程序</h2><p>Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。<br>当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。<br>这个模型非常高效可扩展性非常强，因为webserver一直接受请求而不等待任何读写操作。（这也被称之为非阻塞式IO或者事件驱动IO）<br>在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。<br><img src="http://www.runoob.com/wp-content/uploads/2015/09/event_loop.jpg" alt=""><br>整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。<br>Node.js 有多个内置的事件，我们可以通过引入 events 模块，并通过实例化 EventEmitter 类来绑定和监听事件，如下实例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 引入 events 模块</span><br><span class="line">var events &#x3D; require(&#39;events&#39;);</span><br><span class="line">&#x2F;&#x2F; 创建 eventEmitter 对象</span><br><span class="line">var eventEmitter &#x3D; new events.EventEmitter();</span><br></pre></td></tr></table></figure>
<p>以下程序绑定事件处理程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 绑定事件及事件的处理程序</span><br><span class="line">eventEmitter.on(&#39;eventName&#39;, eventHandler);</span><br></pre></td></tr></table></figure>
<p>我们可以通过程序触发事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 触发事件</span><br><span class="line">eventEmitter.emit(&#39;eventName&#39;);</span><br></pre></td></tr></table></figure>
<p>事件就是需要<strong>eventEmitter.on</strong>去绑定一个事件通过<strong>eventEmitter.emit</strong>去触发这个事件其次说的是 事件的<strong>接收</strong>和<strong>发生</strong>是分开的 就像 一个外卖店你可以不停的接受很多订单, 接受以后开始告诉厨师去做外卖, 做好的外卖对应的外送给每个用户，如果单线程的话那只能是接收一个订单, 做好以后在接收下一个外卖订单，明显效率非常低。<br>事件可以不停的接受不停的发生也是为了提高效率。</p>
<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>创建 main.js 文件，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 引入 events 模块</span><br><span class="line">var events &#x3D; require(&#39;events&#39;);</span><br><span class="line">&#x2F;&#x2F; 创建 eventEmitter 对象</span><br><span class="line">var eventEmitter &#x3D; new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建事件处理程序</span><br><span class="line">var connectHandler &#x3D; function connected() &#123;</span><br><span class="line">   console.log(&#39;连接成功。&#39;);</span><br><span class="line">  </span><br><span class="line">   &#x2F;&#x2F; 触发 data_received 事件 </span><br><span class="line">   eventEmitter.emit(&#39;data_received&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 绑定 connection 事件处理程序</span><br><span class="line">eventEmitter.on(&#39;connection&#39;, connectHandler);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 使用匿名函数绑定 data_received 事件</span><br><span class="line">eventEmitter.on(&#39;data_received&#39;, function()&#123;</span><br><span class="line">   console.log(&#39;数据接收成功。&#39;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 触发 connection 事件 </span><br><span class="line">eventEmitter.emit(&#39;connection&#39;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;程序执行完毕。&quot;);</span><br></pre></td></tr></table></figure>
<p>接下来让我们执行以上代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">连接成功。</span><br><span class="line">数据接收成功。</span><br><span class="line">程序执行完毕。</span><br></pre></td></tr></table></figure>
<h2 id="Node-应用程序是如何工作的？"><a href="#Node-应用程序是如何工作的？" class="headerlink" title="Node 应用程序是如何工作的？"></a>Node 应用程序是如何工作的？</h2><p>在 Node 应用程序中，执行异步操作的函数将回调函数作为最后一个参数， 回调函数接收错误对象作为第一个参数。<br>接下来让我们来重新看下前面的实例，创建一个 input.txt ,文件内容如下：<br><code>菜鸟教程官网地址：www.runoob.com</code><br>创建 main.js 文件，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">fs.readFile(&#39;input.txt&#39;, function (err, data) &#123;</span><br><span class="line">   if (err)&#123;</span><br><span class="line">      console.log(err.stack);</span><br><span class="line">      return;</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(data.toString());</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;程序执行完毕&quot;);</span><br></pre></td></tr></table></figure>
<p>以上程序中 fs.readFile() 是异步函数用于读取文件。 如果在读取文件过程中发生错误，错误 err 对象就会输出错误信息。<br>如果没发生错误，readFile 跳过 err 对象的输出，文件内容就通过回调函数输出。<br>执行以上代码，执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">程序执行完毕</span><br><span class="line">菜鸟教程官网地址：www.runoob.com</span><br></pre></td></tr></table></figure>
<p>接下来我们删除 input.txt 文件，执行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">程序执行完毕</span><br><span class="line">Error: ENOENT, open &#39;input.txt&#39;</span><br></pre></td></tr></table></figure>
<p>因为文件 input.txt 不存在，所以输出了错误信息。</p>
<hr>
<h1 id="Node-js-EventEmitter"><a href="#Node-js-EventEmitter" class="headerlink" title="Node.js EventEmitter"></a>Node.js EventEmitter</h1><p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。<br>Node.js 里面的许多对象都会分发事件：一个 net.Server 对象会在每次有新连接时触发一个事件， 一个 fs.readStream 对象会在文件被打开的时候触发一个事件。 所有这些产生事件的对象都是 events.EventEmitter 的实例。</p>
<h2 id="EventEmitter-类"><a href="#EventEmitter-类" class="headerlink" title="EventEmitter 类"></a>EventEmitter 类</h2><p>events 模块只提供了一个对象： events.EventEmitter。EventEmitter 的核心就是事件触发与事件监听器功能的封装。<br>你可以通过require(“events”);来访问该模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 引入 events 模块</span><br><span class="line">var events &#x3D; require(&#39;events&#39;);</span><br><span class="line">&#x2F;&#x2F; 创建 eventEmitter 对象</span><br><span class="line">var eventEmitter &#x3D; new events.EventEmitter();</span><br></pre></td></tr></table></figure>
<p>EventEmitter 对象如果在实例化时发生错误，会触发 error 事件。当添加新的监听器时，newListener 事件会触发，当监听器被移除时，removeListener 事件被触发。<br>下面我们用一个简单的例子说明 EventEmitter 的用法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;event.js 文件</span><br><span class="line">var EventEmitter &#x3D; require(&#39;events&#39;).EventEmitter; </span><br><span class="line">var event &#x3D; new EventEmitter(); </span><br><span class="line">event.on(&#39;some_event&#39;, function() &#123; </span><br><span class="line">    console.log(&#39;some_event 事件触发&#39;); </span><br><span class="line">&#125;); </span><br><span class="line">setTimeout(function() &#123; </span><br><span class="line">    event.emit(&#39;some_event&#39;); </span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>
<p>执行结果如下：<br>运行这段代码，1 秒后控制台输出了 <code>&#39;some_event 事件触发&#39;</code>。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setTimeout 在 1000 毫秒以后向 event 对象发送事件 some_event，此时会调用some_event 的监听器。<br>EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件，EventEmitter 支持 若干个事件监听器。<br>当事件触发时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。<br>让我们以下面的例子解释这个过程：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;event.js 文件</span><br><span class="line">var events &#x3D; require(&#39;events&#39;); </span><br><span class="line">var emitter &#x3D; new events.EventEmitter(); </span><br><span class="line">emitter.on(&#39;someEvent&#39;, function(arg1, arg2) &#123; </span><br><span class="line">    console.log(&#39;listener1&#39;, arg1, arg2); </span><br><span class="line">&#125;); </span><br><span class="line">emitter.on(&#39;someEvent&#39;, function(arg1, arg2) &#123; </span><br><span class="line">    console.log(&#39;listener2&#39;, arg1, arg2); </span><br><span class="line">&#125;); </span><br><span class="line">emitter.emit(&#39;someEvent&#39;, &#39;arg1 参数&#39;, &#39;arg2 参数&#39;);</span><br></pre></td></tr></table></figure>
<p>执行以上代码，运行的结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node event.js </span><br><span class="line">listener1 arg1 参数 arg2 参数</span><br><span class="line">listener2 arg1 参数 arg2 参数</span><br></pre></td></tr></table></figure>
<p>以上例子中，emitter 为事件 someEvent 注册了两个事件监听器，然后触发了 someEvent 事件。<br>运行结果中可以看到两个事件监听器回调函数被先后调用。 这就是EventEmitter最简单的用法。<br>EventEmitter 提供了多个属性，如 on 和 emit。on 函数用于绑定事件函数，emit 属性用于触发一个事件。接下来我们来具体看下 EventEmitter 的属性介绍。</p>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><ul>
<li><h3 id="addListener-event-listener"><a href="#addListener-event-listener" class="headerlink" title="addListener(event, listener)"></a>addListener(event, listener)</h3>为指定事件添加一个监听器到监听器数组的尾部。</li>
<li><h3 id="on-event-listener"><a href="#on-event-listener" class="headerlink" title="on(event, listener)"></a>on(event, listener)</h3>为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数。<br>两种方法没有区别<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.on(&#39;connection&#39;, function (stream) &#123;</span><br><span class="line">  console.log(&#39;someone connected!&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><h3 id="once-event-listener"><a href="#once-event-listener" class="headerlink" title="once(event, listener)"></a>once(event, listener)</h3>为指定事件注册一个单次监听器，即 监听器最多只会触发一次，触发后立刻解除该监听器。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server.once(&#39;connection&#39;, function (stream) &#123;</span><br><span class="line">  console.log(&#39;Ah, we have our first user!&#39;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li>
<li><h3 id="removeListener-event-listener"><a href="#removeListener-event-listener" class="headerlink" title="removeListener(event, listener)"></a>removeListener(event, listener)</h3>移除指定事件的某个监听器，监听器必须是该事件已经注册过的监听器。<br>它接受两个参数，第一个是事件名称，第二个是回调函数名称。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var callback &#x3D; function(stream) &#123;</span><br><span class="line">  console.log(&#39;someone connected!&#39;);</span><br><span class="line">&#125;;</span><br><span class="line">server.on(&#39;connection&#39;, callback);</span><br><span class="line">&#x2F;&#x2F; ...</span><br><span class="line">server.removeListener(&#39;connection&#39;, callback);</span><br></pre></td></tr></table></figure></li>
<li><h3 id="removeAllListeners-event"><a href="#removeAllListeners-event" class="headerlink" title="removeAllListeners([event])"></a>removeAllListeners([event])</h3>移除所有事件的所有监听器， 如果指定事件，则移除指定事件的所有监听器。</li>
<li><h3 id="setMaxListeners-n"><a href="#setMaxListeners-n" class="headerlink" title="setMaxListeners(n)"></a>setMaxListeners(n)</h3>默认情况下， EventEmitters 如果你添加的监听器超过 10 个就会输出警告信息。 setMaxListeners 函数用于提高监听器的默认限制的数量。</li>
<li><h3 id="listeners-event"><a href="#listeners-event" class="headerlink" title="listeners(event)"></a>listeners(event)</h3>返回指定事件的监听器数组。</li>
<li><h3 id="emit-event-arg1-arg2-…"><a href="#emit-event-arg1-arg2-…" class="headerlink" title="emit(event, [arg1], [arg2], […])"></a>emit(event, [arg1], [arg2], […])</h3>按参数的顺序执行每个监听器，如果事件有注册监听返回 true，否则返回 false。</li>
</ul>
<h2 id="类方法"><a href="#类方法" class="headerlink" title="类方法"></a>类方法</h2><ul>
<li><h3 id="listenerCount-emitter-event"><a href="#listenerCount-emitter-event" class="headerlink" title="listenerCount(emitter, event)"></a>listenerCount(emitter, event)</h3>返回指定事件的监听器数量。<br><code>events.emitter.listenerCount(eventName)</code></li>
</ul>
<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><ul>
<li><h3 id="newListener"><a href="#newListener" class="headerlink" title="newListener"></a>newListener</h3><ul>
<li>event - 字符串，事件名称</li>
<li>listener - 处理事件函数<br>该事件在添加新监听器时被触发。</li>
</ul>
</li>
<li><h3 id="removeListener"><a href="#removeListener" class="headerlink" title="removeListener"></a>removeListener</h3><ul>
<li>event - 字符串，事件名称</li>
<li>listener - 处理事件函数<br>从指定监听器数组中删除一个监听器。需要注意的是，此操作将会改变处于被删监听器之后的那些监听器的索引。</li>
</ul>
</li>
</ul>
<h2 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h2><p>以下实例通过 connection（连接）事件演示了 EventEmitter 类的应用。<br>创建 main.js 文件，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">var events &#x3D; require(&#39;events&#39;);</span><br><span class="line">var eventEmitter &#x3D; new events.EventEmitter();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 监听器 #1</span><br><span class="line">var listener1 &#x3D; function listener1() &#123;</span><br><span class="line">   console.log(&#39;监听器 listener1 执行。&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 监听器 #2</span><br><span class="line">var listener2 &#x3D; function listener2() &#123;</span><br><span class="line">  console.log(&#39;监听器 listener2 执行。&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 绑定 connection 事件，处理函数为 listener1 </span><br><span class="line">eventEmitter.addListener(&#39;connection&#39;, listener1);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 绑定 connection 事件，处理函数为 listener2</span><br><span class="line">eventEmitter.on(&#39;connection&#39;, listener2);</span><br><span class="line"></span><br><span class="line">var eventListeners &#x3D; eventEmitter.listenerCount(&#39;connection&#39;);</span><br><span class="line">console.log(eventListeners + &quot; 个监听器监听连接事件。&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理 connection 事件 </span><br><span class="line">eventEmitter.emit(&#39;connection&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 移除监绑定的 listener1 函数</span><br><span class="line">eventEmitter.removeListener(&#39;connection&#39;, listener1);</span><br><span class="line">console.log(&quot;listener1 不再受监听。&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 触发连接事件</span><br><span class="line">eventEmitter.emit(&#39;connection&#39;);</span><br><span class="line"></span><br><span class="line">eventListeners &#x3D; eventEmitter.listenerCount(&#39;connection&#39;);</span><br><span class="line">console.log(eventListeners + &quot; 个监听器监听连接事件。&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;程序执行完毕。&quot;);</span><br></pre></td></tr></table></figure>
<p>以上代码，执行结果如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">2 个监听器监听连接事件。</span><br><span class="line">监听器 listener1 执行。</span><br><span class="line">监听器 listener2 执行。</span><br><span class="line">listener1 不再受监听。</span><br><span class="line">监听器 listener2 执行。</span><br><span class="line">1 个监听器监听连接事件。</span><br><span class="line">程序执行完毕。</span><br></pre></td></tr></table></figure>

<h2 id="error-事件"><a href="#error-事件" class="headerlink" title="error 事件"></a>error 事件</h2><p>EventEmitter 定义了一个特殊的事件 error，它包含了错误的语义，我们在遇到 异常的时候通常会触发 error 事件。<br>当 error 被触发时，EventEmitter 规定如果没有响 应的监听器，Node.js 会把它当作异常，退出程序并输出错误信息。<br>我们一般要为会触发 error 事件的对象设置监听器，避免遇到错误后整个程序崩溃。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var events &#x3D; require(&#39;events&#39;); </span><br><span class="line">var emitter &#x3D; new events.EventEmitter(); </span><br><span class="line">emitter.emit(&#39;error&#39;);</span><br></pre></td></tr></table></figure>
<p>运行时会显示以下错误：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">node.js:201 </span><br><span class="line">throw e; &#x2F;&#x2F; process.nextTick error, or &#39;error&#39; event on first tick </span><br><span class="line">^ </span><br><span class="line">Error: Uncaught, unspecified &#39;error&#39; event. </span><br><span class="line">at EventEmitter.emit (events.js:50:15) </span><br><span class="line">at Object.&lt;anonymous&gt; (&#x2F;home&#x2F;byvoid&#x2F;error.js:5:9) </span><br><span class="line">at Module._compile (module.js:441:26) </span><br><span class="line">at Object..js (module.js:459:10) </span><br><span class="line">at Module.load (module.js:348:31) </span><br><span class="line">at Function._load (module.js:308:12) </span><br><span class="line">at Array.0 (module.js:479:10) </span><br><span class="line">at EventEmitter._tickCallback (node.js:192:40)</span><br></pre></td></tr></table></figure>

<h2 id="继承-EventEmitter"><a href="#继承-EventEmitter" class="headerlink" title="继承 EventEmitter"></a>继承 EventEmitter</h2><p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、net、 http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。<br>为什么要这样做呢？原因有两点：<br>首先，具有某个实体功能的对象实现事件符合语义， 事件的监听和发生应该是一个对象的方法。<br>其次 JavaScript 的对象机制是基于原型的，支持部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</p>
<hr>
<h1 id="Node-js-Buffer-缓冲区"><a href="#Node-js-Buffer-缓冲区" class="headerlink" title="Node.js Buffer(缓冲区)"></a>Node.js Buffer(缓冲区)</h1><p>JavaScript 语言自身只有字符串数据类型，没有二进制数据类型。<br>但在处理像TCP流或文件流时，必须使用到二进制数据。因此在 Node.js中，定义了一个 Buffer 类，该类用来创建一个专门存放二进制数据的缓存区。<br>在 Node.js 中，Buffer 类是随 Node 内核一起发布的核心库。Buffer 库为 Node.js 带来了一种存储原始数据的方法，可以让 Node.js 处理二进制数据，每当需要在 Node.js 中处理I/O操作中移动的数据时，就有可能使用 Buffer 库。原始数据存储在 Buffer 类的实例中。一个 Buffer 类似于一个整数数组，但它对应于 V8 堆内存之外的一块原始内存。</p>
<h2 id="Buffer-与字符编码"><a href="#Buffer-与字符编码" class="headerlink" title="Buffer 与字符编码"></a>Buffer 与字符编码</h2><p>Buffer 实例一般用于表示编码字符的序列，比如 UTF-8 、 UCS2 、 Base64 、或十六进制编码的数据。 通过使用显式的字符编码，就可以在 Buffer 实例与普通的 JavaScript 字符串之间进行相互转换</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const buf &#x3D; Buffer.from(&#39;runoob&#39;, &#39;ascii&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出 72756e6f6f62</span><br><span class="line">console.log(buf.toString(&#39;hex&#39;));</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出 cnVub29i</span><br><span class="line">console.log(buf.toString(&#39;base64&#39;));</span><br></pre></td></tr></table></figure>
<p><strong>Node.js 目前支持的字符编码包括：</strong></p>
<ul>
<li>ascii - 仅支持 7 位 ASCII 数据。如果设置去掉高位的话，这种编码是非常快的。</li>
<li>utf8 - 多字节编码的 Unicode 字符。许多网页和其他文档格式都使用 UTF-8 。</li>
<li>utf16le - 2 或 4 个字节，小字节序编码的 Unicode 字符。支持代理对（U+10000 至 U+10FFFF）。</li>
<li>ucs2 - utf16le 的别名。</li>
<li>base64 - Base64 编码。</li>
<li>latin1 - 一种把 Buffer 编码成一字节编码的字符串的方式。</li>
<li>binary - latin1 的别名。</li>
<li>hex - 将每个字节编码为两个十六进制字符。</li>
</ul>
<h2 id="创建-Buffer-类"><a href="#创建-Buffer-类" class="headerlink" title="创建 Buffer 类"></a>创建 Buffer 类</h2><p>Buffer 提供了以下 API 来创建 Buffer 类：</p>
<ul>
<li><strong>Buffer.alloc(size[, fill[, encoding]])：</strong> 返回一个指定大小的 Buffer 实例，如果没有设置 fill，则默认填满 0<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个长度为 10、且用 0 填充的 Buffer。</span><br><span class="line">const buf1 &#x3D; Buffer.alloc(10);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个长度为 10、且用 0x1 填充的 Buffer。 </span><br><span class="line">const buf2 &#x3D; Buffer.alloc(10, 1);</span><br></pre></td></tr></table></figure></li>
<li><strong>Buffer.allocUnsafe(size)：</strong> 返回一个指定大小的 Buffer 实例，但是它不会被初始化，所以它可能包含敏感的数据<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个长度为 10、且未初始化的 Buffer。</span><br><span class="line">&#x2F;&#x2F; 这个方法比调用 Buffer.alloc() 更快，</span><br><span class="line">&#x2F;&#x2F; 但返回的 Buffer 实例可能包含旧数据，</span><br><span class="line">&#x2F;&#x2F; 因此需要使用 fill() 或 write() 重写。</span><br><span class="line">const buf3 &#x3D; Buffer.allocUnsafe(10);</span><br></pre></td></tr></table></figure></li>
<li><strong>Buffer.allocUnsafeSlow(size)</strong> 返回一个指定大小没有初始化的 Buffer 实例，但是将直接申请内存</li>
<li><strong>Buffer.from(array)：</strong> 返回一个被 array 的值初始化的新的 Buffer 实例（传入的 array 的元素只能是数字，不然就会自动被 0 覆盖）<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个包含 [0x1, 0x2, 0x3] 的 Buffer。</span><br><span class="line">const buf4 &#x3D; Buffer.from([1, 2, 3]);</span><br></pre></td></tr></table></figure></li>
<li><strong>Buffer.from(arrayBuffer[, byteOffset[, length]])：</strong> 返回一个新建的与给定的 ArrayBuffer 共享同一内存的 Buffer。</li>
<li><strong>Buffer.from(buffer)：</strong> 复制传入的 Buffer 实例的数据，并返回一个新的 Buffer 实例</li>
<li><strong>Buffer.from(string[, encoding])：</strong> 返回一个被 string 的值初始化的新的 Buffer 实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个包含 UTF-8 字节 [0x74, 0xc3, 0xa9, 0x73, 0x74] 的 Buffer。</span><br><span class="line">const buf5 &#x3D; Buffer.from(&#39;tést&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个包含 Latin-1 字节 [0x74, 0xe9, 0x73, 0x74] 的 Buffer。</span><br><span class="line">const buf6 &#x3D; Buffer.from(&#39;tést&#39;, &#39;latin1&#39;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="写入缓冲区"><a href="#写入缓冲区" class="headerlink" title="写入缓冲区"></a>写入缓冲区</h2><ul>
<li>语法<br>写入 Node 缓冲区的语法如下所示：<br><code>buf.write(string[, offset[, length]][, encoding])</code></li>
<li>参数<br>参数描述如下：<ul>
<li>string - 写入缓冲区的字符串。</li>
<li>offset - 缓冲区开始写入的索引值，默认为 0 。</li>
<li>length - 写入的字节数，默认为 buffer.length</li>
<li>encoding - 使用的编码。默认为 ‘utf8’ 。<br>根据 encoding 的字符编码写入 string 到 buf 中的 offset 位置。 length 参数是写入的字节数。 如果 buf 没有足够的空间保存整个字符串，则只会写入 string 的一部分。 只部分解码的字符不会被写入。</li>
</ul>
</li>
<li>返回值<br>返回实际写入的大小。如果 buffer 空间不足， 则只会写入部分字符串。</li>
<li>实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">buf &#x3D; Buffer.alloc(256);</span><br><span class="line">len &#x3D; buf.write(&quot;www.runoob.com&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;写入字节数 : &quot;+  len);</span><br></pre></td></tr></table></figure>
执行以上代码，输出结果为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$node main.js</span><br><span class="line">写入字节数 : 14</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="从缓冲区读取数据"><a href="#从缓冲区读取数据" class="headerlink" title="从缓冲区读取数据"></a>从缓冲区读取数据</h2><ul>
<li>语法<br>读取 Node 缓冲区数据的语法如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.toString([encoding[, start[, end]]])</span><br></pre></td></tr></table></figure></li>
<li>参数<ul>
<li>encoding - 使用的编码。默认为 ‘utf8’ 。</li>
<li>start - 指定开始读取的索引位置，默认为 0。</li>
<li>end - 结束位置，默认为缓冲区的末尾。</li>
</ul>
</li>
<li>返回值<br>解码缓冲区数据并使用指定的编码返回字符串。</li>
<li>实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buf &#x3D; Buffer.alloc(26);</span><br><span class="line">for (var i &#x3D; 0 ; i &lt; 26 ; i++) &#123;</span><br><span class="line">  buf[i] &#x3D; i + 97;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log( buf.toString(&#39;ascii&#39;));       &#x2F;&#x2F; 输出: abcdefghijklmnopqrstuvwxyz</span><br><span class="line">console.log( buf.toString(&#39;ascii&#39;,0,5));   &#x2F;&#x2F; 输出: abcde</span><br><span class="line">console.log( buf.toString(&#39;utf8&#39;,0,5));    &#x2F;&#x2F; 输出: abcde</span><br><span class="line">console.log( buf.toString(undefined,0,5)); &#x2F;&#x2F; 使用 &#39;utf8&#39; 编码, 并输出: abcde</span><br></pre></td></tr></table></figure>
执行以上代码，输出结果为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">abcdefghijklmnopqrstuvwxyz</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br><span class="line">abcde</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="将-Buffer-转换为-JSON-对象"><a href="#将-Buffer-转换为-JSON-对象" class="headerlink" title="将 Buffer 转换为 JSON 对象"></a>将 Buffer 转换为 JSON 对象</h2><ul>
<li>语法<br>将 Node Buffer 转换为 JSON 对象的函数语法格式如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.toJSON()</span><br></pre></td></tr></table></figure>
当字符串化一个 Buffer 实例时，<code>JSON.stringify()</code> 会隐式地调用该 toJSON()。</li>
<li>返回值<br>返回 JSON 对象。</li>
<li>实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">const buf &#x3D; Buffer.from([0x1, 0x2, 0x3, 0x4, 0x5]);</span><br><span class="line">const json &#x3D; JSON.stringify(buf);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出: &#123;&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]&#125;</span><br><span class="line">console.log(json);</span><br><span class="line"></span><br><span class="line">const copy &#x3D; JSON.parse(json, (key, value) &#x3D;&gt; &#123;</span><br><span class="line">  return value &amp;&amp; value.type &#x3D;&#x3D;&#x3D; &#39;Buffer&#39; ?</span><br><span class="line">    Buffer.from(value.data) :</span><br><span class="line">    value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出: &lt;Buffer 01 02 03 04 05&gt;</span><br><span class="line">console.log(copy);</span><br></pre></td></tr></table></figure>
执行以上代码，输出结果为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;type&quot;:&quot;Buffer&quot;,&quot;data&quot;:[1,2,3,4,5]&#125;</span><br><span class="line">&lt;Buffer 01 02 03 04 05&gt;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="缓冲区合并"><a href="#缓冲区合并" class="headerlink" title="缓冲区合并"></a>缓冲区合并</h2><ul>
<li>语法<br>Node 缓冲区合并的语法如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Buffer.concat(list[, totalLength])</span><br></pre></td></tr></table></figure></li>
<li>参数<br>参数描述如下：<ul>
<li>list - 用于合并的 Buffer 对象数组列表。</li>
<li>totalLength - 指定合并后Buffer对象的总长度。</li>
</ul>
</li>
<li>返回值<br>返回一个多个成员合并的新 Buffer 对象。</li>
<li>实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var buffer1 &#x3D; Buffer.from((&#39;菜鸟教程&#39;));</span><br><span class="line">var buffer2 &#x3D; Buffer.from((&#39;www.runoob.com&#39;));</span><br><span class="line">var buffer3 &#x3D; Buffer.concat([buffer1,buffer2]);</span><br><span class="line">console.log(&quot;buffer3 内容: &quot; + buffer3.toString());</span><br></pre></td></tr></table></figure>
执行以上代码，输出结果为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer3 内容: 菜鸟教程www.runoob.com</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="缓冲区比较"><a href="#缓冲区比较" class="headerlink" title="缓冲区比较"></a>缓冲区比较</h2><ul>
<li>语法<br>Node Buffer 比较的函数语法如下所示, 该方法在 Node.js v0.12.2 版本引入：<br>这个方法是按位比较的。buffer1 的第一位比较 buffer2 的第一位，相等的话比较第二位以此类推直到得出结果。<br>举例：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var buffer1 &#x3D; Buffer.from(&#39;ABCDEF99&#39;);</span><br><span class="line">var buffer2 &#x3D; Buffer.from(&#39;ABCDEF98765&#39;);</span><br></pre></td></tr></table></figure>
上面那个 buffer1 和 buffer2 比较的话，result 的结果是 1，前面的结果都是相等，直到比较 9&gt;8 的时候出结果。按位逐一比较直到出结果。<br>那么说如果把 buffer1 设为 12313213121 这种纯数字呢，数字和字母比较的结果就是 -1。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.compare(otherBuffer);</span><br></pre></td></tr></table></figure></li>
<li>参数<br>参数描述如下：<ul>
<li>otherBuffer - 与 buf 对象比较的另外一个 Buffer 对象。</li>
</ul>
</li>
<li>返回值<br>返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。</li>
<li>实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var buffer1 &#x3D; Buffer.from(&#39;ABC&#39;);</span><br><span class="line">var buffer2 &#x3D; Buffer.from(&#39;ABCD&#39;);</span><br><span class="line">var result &#x3D; buffer1.compare(buffer2);</span><br><span class="line"></span><br><span class="line">if(result &lt; 0) &#123;</span><br><span class="line">   console.log(buffer1 + &quot; 在 &quot; + buffer2 + &quot;之前&quot;);</span><br><span class="line">&#125;else if(result &#x3D;&#x3D; 0)&#123;</span><br><span class="line">   console.log(buffer1 + &quot; 与 &quot; + buffer2 + &quot;相同&quot;);</span><br><span class="line">&#125;else &#123;</span><br><span class="line">   console.log(buffer1 + &quot; 在 &quot; + buffer2 + &quot;之后&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
执行以上代码，输出结果为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ABC在ABCD之前</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="拷贝缓冲区"><a href="#拷贝缓冲区" class="headerlink" title="拷贝缓冲区"></a>拷贝缓冲区</h2><ul>
<li>语法<br>Node 缓冲区拷贝语法如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</span><br></pre></td></tr></table></figure></li>
<li>参数<br>参数描述如下：<ul>
<li>targetBuffer - 要拷贝的 Buffer 对象。</li>
<li>targetStart - 数字, 可选, 默认: 0</li>
<li>sourceStart - 数字, 可选, 默认: 0</li>
<li>sourceEnd - 数字, 可选, 默认: buffer.length</li>
</ul>
</li>
<li>返回值<br>没有返回值。</li>
<li>实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var buf1 &#x3D; Buffer.from(&#39;abcdefghijkl&#39;);</span><br><span class="line">var buf2 &#x3D; Buffer.from(&#39;RUNOOB&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;将 buf2 插入到 buf1 指定位置上</span><br><span class="line">buf2.copy(buf1, 2);</span><br><span class="line"></span><br><span class="line">console.log(buf1.toString());</span><br></pre></td></tr></table></figure>
执行以上代码，输出结果为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abRUNOOBijkl</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="缓冲区裁剪"><a href="#缓冲区裁剪" class="headerlink" title="缓冲区裁剪"></a>缓冲区裁剪</h2><ul>
<li>语法<br>Node 缓冲区裁剪语法如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.slice([start[, end]])</span><br></pre></td></tr></table></figure></li>
<li>参数<br>参数描述如下：<ul>
<li>start - 数字, 可选, 默认: 0</li>
<li>end - 数字, 可选, 默认: buffer.length</li>
</ul>
</li>
<li>返回值<br>返回一个新的缓冲区，<strong>它和旧缓冲区指向同一块内存</strong>，但是从索引 start 到 end 的位置剪切。</li>
<li>实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var buffer1 &#x3D; Buffer.from(&#39;runoob&#39;);</span><br><span class="line">&#x2F;&#x2F; 剪切缓冲区</span><br><span class="line">var buffer2 &#x3D; buffer1.slice(0,2);</span><br><span class="line">console.log(&quot;buffer2 content: &quot; + buffer2.toString());</span><br></pre></td></tr></table></figure>
执行以上代码，输出结果为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer2 content: ru</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="缓冲区长度"><a href="#缓冲区长度" class="headerlink" title="缓冲区长度"></a>缓冲区长度</h2><ul>
<li>语法<br>Node 缓冲区长度计算语法如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buf.length;</span><br></pre></td></tr></table></figure></li>
<li>返回值<br>返回 Buffer 对象所占据的内存长度。</li>
<li>实例<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var buffer &#x3D; Buffer.from(&#39;www.runoob.com&#39;);</span><br><span class="line">&#x2F;&#x2F;  缓冲区长度</span><br><span class="line">console.log(&quot;buffer length: &quot; + buffer.length);</span><br></pre></td></tr></table></figure>
执行以上代码，输出结果为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">buffer length: 14</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="方法手册"><a href="#方法手册" class="headerlink" title="方法手册"></a>方法手册</h2><ul>
<li><h3 id="buf-length"><a href="#buf-length" class="headerlink" title="buf.length"></a>buf.length</h3>返回这个 buffer 的 bytes 数。注意这未必是 buffer 里面内容的大小。length 是 buffer 对象所分配的内存数，它不会随着这个 buffer 对象内容的改变而改变。</li>
<li><h3 id="buf-write-string-offset-length-encoding"><a href="#buf-write-string-offset-length-encoding" class="headerlink" title="buf.write(string[, offset[, length]][, encoding])"></a>buf.write(string[, offset[, length]][, encoding])</h3>根据参数 offset 偏移量和指定的 encoding 编码方式，将参数 string 数据写入buffer。 offset 偏移量默认值是 0, encoding 编码方式默认是 utf8。 length 长度是将要写入的字符串的 bytes 大小。 返回 number 类型，表示写入了多少 8 位字节流。如果 buffer 没有足够的空间来放整个 string，它将只会只写入部分字符串。 length 默认是 buffer.length - offset。 这个方法不会出现写入部分字符。</li>
<li><h3 id="buf-writeUIntLE-value-offset-byteLength-noAssert"><a href="#buf-writeUIntLE-value-offset-byteLength-noAssert" class="headerlink" title="buf.writeUIntLE(value, offset, byteLength[, noAssert])"></a>buf.writeUIntLE(value, offset, byteLength[, noAssert])</h3>将 value 写入到 buffer 里， 它由 offset 和 byteLength 决定，最高支持 48 位无符号整数，小端对齐，noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。例如：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const buf &#x3D; Buffer.allocUnsafe(6);</span><br><span class="line"></span><br><span class="line">buf.writeUIntLE(0x1234567890ab, 0, 6);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出: &lt;Buffer ab 90 78 56 34 12&gt;</span><br><span class="line">console.log(buf);</span><br></pre></td></tr></table></figure></li>
<li><h3 id="buf-writeUIntBE-value-offset-byteLength-noAssert"><a href="#buf-writeUIntBE-value-offset-byteLength-noAssert" class="headerlink" title="buf.writeUIntBE(value, offset, byteLength[, noAssert])"></a>buf.writeUIntBE(value, offset, byteLength[, noAssert])</h3>将 value 写入到 buffer 里， 它由 offset 和 byteLength 决定，最高支持 48 位无符号整数，大端对齐。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const buf &#x3D; Buffer.allocUnsafe(6);</span><br><span class="line"></span><br><span class="line">buf.writeUIntBE(0x1234567890ab, 0, 6);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出: &lt;Buffer 12 34 56 78 90 ab&gt;</span><br><span class="line">console.log(buf);</span><br></pre></td></tr></table></figure></li>
<li><h3 id="buf-writeIntLE-value-offset-byteLength-noAssert"><a href="#buf-writeIntLE-value-offset-byteLength-noAssert" class="headerlink" title="buf.writeIntLE(value, offset, byteLength[, noAssert])"></a>buf.writeIntLE(value, offset, byteLength[, noAssert])</h3>将value 写入到 buffer 里， 它由offset 和 byteLength 决定，最高支持48位有符号整数，小端对齐。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</li>
<li><h3 id="buf-writeIntBE-value-offset-byteLength-noAssert"><a href="#buf-writeIntBE-value-offset-byteLength-noAssert" class="headerlink" title="buf.writeIntBE(value, offset, byteLength[, noAssert])"></a>buf.writeIntBE(value, offset, byteLength[, noAssert])</h3>将value 写入到 buffer 里， 它由offset 和 byteLength 决定，最高支持48位有符号整数，大端对齐。noAssert 值为 true 时，不再验证 value 和 offset 的有效性。 默认是 false。</li>
<li><h3 id="buf-readUIntLE-offset-byteLength-noAssert"><a href="#buf-readUIntLE-offset-byteLength-noAssert" class="headerlink" title="buf.readUIntLE(offset, byteLength[, noAssert])"></a>buf.readUIntLE(offset, byteLength[, noAssert])</h3>支持读取 48 位以下的无符号数字，小端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</li>
<li><h3 id="buf-readUIntBE-offset-byteLength-noAssert"><a href="#buf-readUIntBE-offset-byteLength-noAssert" class="headerlink" title="buf.readUIntBE(offset, byteLength[, noAssert])"></a>buf.readUIntBE(offset, byteLength[, noAssert])</h3>支持读取 48 位以下的无符号数字，大端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</li>
<li><h3 id="buf-readIntLE-offset-byteLength-noAssert"><a href="#buf-readIntLE-offset-byteLength-noAssert" class="headerlink" title="buf.readIntLE(offset, byteLength[, noAssert])"></a>buf.readIntLE(offset, byteLength[, noAssert])</h3>支持读取 48 位以下的有符号数字，小端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</li>
<li><h3 id="buf-readIntBE-offset-byteLength-noAssert"><a href="#buf-readIntBE-offset-byteLength-noAssert" class="headerlink" title="buf.readIntBE(offset, byteLength[, noAssert])"></a>buf.readIntBE(offset, byteLength[, noAssert])</h3>支持读取 48 位以下的有符号数字，大端对齐。noAssert 值为 true 时， offset 不再验证是否超过 buffer 的长度，默认为 false。</li>
<li><h3 id="buf-toString-encoding-start-end"><a href="#buf-toString-encoding-start-end" class="headerlink" title="buf.toString([encoding[, start[, end]]])"></a>buf.toString([encoding[, start[, end]]])</h3>根据 encoding 参数（默认是 ‘utf8’）返回一个解码过的 string 类型。还会根据传入的参数 start (默认是 0) 和 end (默认是 buffer.length)作为取值范围。</li>
<li><h3 id="buf-toJSON"><a href="#buf-toJSON" class="headerlink" title="buf.toJSON()"></a>buf.toJSON()</h3>将 Buffer 实例转换为 JSON 对象。</li>
<li><h3 id="buf-index"><a href="#buf-index" class="headerlink" title="buf[index]"></a>buf[index]</h3>获取或设置指定的字节。返回值代表一个字节，所以返回值的合法范围是十六进制0x00到0xFF 或者十进制0至 255。</li>
<li><h3 id="buf-equals-otherBuffer"><a href="#buf-equals-otherBuffer" class="headerlink" title="buf.equals(otherBuffer)"></a>buf.equals(otherBuffer)</h3>比较两个缓冲区是否相等，如果是返回 true，否则返回 false。</li>
<li><h3 id="buf-compare-otherBuffer"><a href="#buf-compare-otherBuffer" class="headerlink" title="buf.compare(otherBuffer)"></a>buf.compare(otherBuffer)</h3>比较两个 Buffer 对象，返回一个数字，表示 buf 在 otherBuffer 之前，之后或相同。</li>
<li><h3 id="buf-copy-targetBuffer-targetStart-sourceStart-sourceEnd"><a href="#buf-copy-targetBuffer-targetStart-sourceStart-sourceEnd" class="headerlink" title="buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])"></a>buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</h3>buffer 拷贝，源和目标可以相同。 targetStart 目标开始偏移和 sourceStart 源开始偏移默认都是 0。 sourceEnd 源结束位置偏移默认是源的长度 buffer.length 。</li>
<li><h3 id="buf-slice-start-end"><a href="#buf-slice-start-end" class="headerlink" title="buf.slice([start[, end]])"></a>buf.slice([start[, end]])</h3>剪切 Buffer 对象，根据 start(默认是 0 ) 和 end (默认是 buffer.length ) 偏移和裁剪了索引。 负的索引是从 buffer 尾部开始计算的。</li>
<li><h3 id="buf-readUInt8-offset-noAssert"><a href="#buf-readUInt8-offset-noAssert" class="headerlink" title="buf.readUInt8(offset[, noAssert])"></a>buf.readUInt8(offset[, noAssert])</h3>根据指定的偏移量，读取一个无符号 8 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 如果这样 offset 可能会超出buffer 的末尾。默认是 false。</li>
<li><h3 id="buf-readUInt16LE-offset-noAssert"><a href="#buf-readUInt16LE-offset-noAssert" class="headerlink" title="buf.readUInt16LE(offset[, noAssert])"></a>buf.readUInt16LE(offset[, noAssert])</h3>根据指定的偏移量，使用特殊的 endian 字节序格式读取一个无符号 16 位整数。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</li>
<li><h3 id="buf-readUInt16BE-offset-noAssert"><a href="#buf-readUInt16BE-offset-noAssert" class="headerlink" title="buf.readUInt16BE(offset[, noAssert])"></a>buf.readUInt16BE(offset[, noAssert])</h3>根据指定的偏移量，使用特殊的 endian 字节序格式读取一个无符号 16 位整数，大端对齐。若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</li>
<li><h3 id="buf-readUInt32LE-offset-noAssert"><a href="#buf-readUInt32LE-offset-noAssert" class="headerlink" title="buf.readUInt32LE(offset[, noAssert])"></a>buf.readUInt32LE(offset[, noAssert])</h3>根据指定的偏移量，使用指定的 endian 字节序格式读取一个无符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</li>
<li><h3 id="buf-readUInt32BE-offset-noAssert"><a href="#buf-readUInt32BE-offset-noAssert" class="headerlink" title="buf.readUInt32BE(offset[, noAssert])"></a>buf.readUInt32BE(offset[, noAssert])</h3>根据指定的偏移量，使用指定的 endian 字节序格式读取一个无符号 32 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</li>
<li><h3 id="buf-readInt8-offset-noAssert"><a href="#buf-readInt8-offset-noAssert" class="headerlink" title="buf.readInt8(offset[, noAssert])"></a>buf.readInt8(offset[, noAssert])</h3>根据指定的偏移量，读取一个有符号 8 位整数。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</li>
<li><h3 id="buf-readInt16LE-offset-noAssert"><a href="#buf-readInt16LE-offset-noAssert" class="headerlink" title="buf.readInt16LE(offset[, noAssert])"></a>buf.readInt16LE(offset[, noAssert])</h3>根据指定的偏移量，使用特殊的 endian 格式读取一个 有符号 16 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</li>
<li><h3 id="buf-readInt16BE-offset-noAssert"><a href="#buf-readInt16BE-offset-noAssert" class="headerlink" title="buf.readInt16BE(offset[, noAssert])"></a>buf.readInt16BE(offset[, noAssert])</h3>根据指定的偏移量，使用特殊的 endian 格式读取一个 有符号 16 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出 buffer 的末尾。默认是 false。</li>
<li><h3 id="buf-readInt32LE-offset-noAssert"><a href="#buf-readInt32LE-offset-noAssert" class="headerlink" title="buf.readInt32LE(offset[, noAssert])"></a>buf.readInt32LE(offset[, noAssert])</h3>根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</li>
<li><h3 id="buf-readInt32BE-offset-noAssert"><a href="#buf-readInt32BE-offset-noAssert" class="headerlink" title="buf.readInt32BE(offset[, noAssert])"></a>buf.readInt32BE(offset[, noAssert])</h3>根据指定的偏移量，使用指定的 endian 字节序格式读取一个有符号 32 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</li>
<li><h3 id="buf-readFloatLE-offset-noAssert"><a href="#buf-readFloatLE-offset-noAssert" class="headerlink" title="buf.readFloatLE(offset[, noAssert])"></a>buf.readFloatLE(offset[, noAssert])</h3>根据指定的偏移量，使用指定的 endian 字节序格式读取一个 32 位双浮点数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer的末尾。默认是 false。</li>
<li><h3 id="buf-readFloatBE-offset-noAssert"><a href="#buf-readFloatBE-offset-noAssert" class="headerlink" title="buf.readFloatBE(offset[, noAssert])"></a>buf.readFloatBE(offset[, noAssert])</h3>根据指定的偏移量，使用指定的 endian 字节序格式读取一个 32 位双浮点数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer的末尾。默认是 false。</li>
<li><h3 id="buf-readDoubleLE-offset-noAssert"><a href="#buf-readDoubleLE-offset-noAssert" class="headerlink" title="buf.readDoubleLE(offset[, noAssert])"></a>buf.readDoubleLE(offset[, noAssert])</h3>根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 位双精度数，小端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</li>
<li><h3 id="buf-readDoubleBE-offset-noAssert"><a href="#buf-readDoubleBE-offset-noAssert" class="headerlink" title="buf.readDoubleBE(offset[, noAssert])"></a>buf.readDoubleBE(offset[, noAssert])</h3>根据指定的偏移量，使用指定的 endian字节序格式读取一个 64 位双精度数，大端对齐。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 offset 可能会超出buffer 的末尾。默认是 false。</li>
<li><h3 id="buf-writeUInt8-value-offset-noAssert"><a href="#buf-writeUInt8-value-offset-noAssert" class="headerlink" title="buf.writeUInt8(value, offset[, noAssert])"></a>buf.writeUInt8(value, offset[, noAssert])</h3>根据传入的 offset 偏移量将 value 写入 buffer。注意：value 必须是一个合法的无符号 8 位整数。 若参数 noAssert 为 true 将不会验证 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则不要使用。默认是 false。</li>
<li><h3 id="buf-writeUInt16LE-value-offset-noAssert"><a href="#buf-writeUInt16LE-value-offset-noAssert" class="headerlink" title="buf.writeUInt16LE(value, offset[, noAssert])"></a>buf.writeUInt16LE(value, offset[, noAssert])</h3>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的无符号 16 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</li>
<li><h3 id="buf-writeUInt16BE-value-offset-noAssert"><a href="#buf-writeUInt16BE-value-offset-noAssert" class="headerlink" title="buf.writeUInt16BE(value, offset[, noAssert])"></a>buf.writeUInt16BE(value, offset[, noAssert])</h3>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的无符号 16 位整数，大端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</li>
<li><h3 id="buf-writeUInt32LE-value-offset-noAssert"><a href="#buf-writeUInt32LE-value-offset-noAssert" class="headerlink" title="buf.writeUInt32LE(value, offset[, noAssert])"></a>buf.writeUInt32LE(value, offset[, noAssert])</h3>根据传入的 offset 偏移量和指定的 endian 格式(LITTLE-ENDIAN:小字节序)将 value 写入buffer。注意：value 必须是一个合法的无符号 32 位整数，小端对齐。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着value 可能过大，或者offset可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</li>
<li><h3 id="buf-writeUInt32BE-value-offset-noAssert"><a href="#buf-writeUInt32BE-value-offset-noAssert" class="headerlink" title="buf.writeUInt32BE(value, offset[, noAssert])"></a>buf.writeUInt32BE(value, offset[, noAssert])</h3>根据传入的 offset 偏移量和指定的 endian 格式(Big-Endian:大字节序)将 value 写入buffer。注意：value 必须是一个合法的有符号 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者offset可能会超出buffer的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</li>
<li><h3 id="buf-writeInt8-value-offset-noAssert"><a href="#buf-writeInt8-value-offset-noAssert" class="headerlink" title="buf.writeInt8(value, offset[, noAssert])"></a>buf.writeInt8(value, offset[, noAssert])</h3></li>
<li><h3 id="buf-writeInt16LE-value-offset-noAssert"><a href="#buf-writeInt16LE-value-offset-noAssert" class="headerlink" title="buf.writeInt16LE(value, offset[, noAssert])"></a>buf.writeInt16LE(value, offset[, noAssert])</h3>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 16 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false 。</li>
<li><h3 id="buf-writeInt16BE-value-offset-noAssert"><a href="#buf-writeInt16BE-value-offset-noAssert" class="headerlink" title="buf.writeInt16BE(value, offset[, noAssert])"></a>buf.writeInt16BE(value, offset[, noAssert])</h3>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 16 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false 。</li>
<li><h3 id="buf-writeInt32LE-value-offset-noAssert"><a href="#buf-writeInt32LE-value-offset-noAssert" class="headerlink" title="buf.writeInt32LE(value, offset[, noAssert])"></a>buf.writeInt32LE(value, offset[, noAssert])</h3>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</li>
<li><h3 id="buf-writeInt32BE-value-offset-noAssert"><a href="#buf-writeInt32BE-value-offset-noAssert" class="headerlink" title="buf.writeInt32BE(value, offset[, noAssert])"></a>buf.writeInt32BE(value, offset[, noAssert])</h3>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个合法的 signed 32 位整数。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</li>
<li><h3 id="buf-writeFloatLE-value-offset-noAssert"><a href="#buf-writeFloatLE-value-offset-noAssert" class="headerlink" title="buf.writeFloatLE(value, offset[, noAssert])"></a>buf.writeFloatLE(value, offset[, noAssert])</h3>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer 。注意：当 value 不是一个 32 位浮点数类型的值时，结果将是不确定的。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</li>
<li><h3 id="buf-writeFloatBE-value-offset-noAssert"><a href="#buf-writeFloatBE-value-offset-noAssert" class="headerlink" title="buf.writeFloatBE(value, offset[, noAssert])"></a>buf.writeFloatBE(value, offset[, noAssert])</h3>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer 。注意：当 value 不是一个 32 位浮点数类型的值时，结果将是不确定的。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value可能过大，或者 offset 可能会超出 buffer 的末尾从而造成 value 被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</li>
<li><h3 id="buf-writeDoubleLE-value-offset-noAssert"><a href="#buf-writeDoubleLE-value-offset-noAssert" class="headerlink" title="buf.writeDoubleLE(value, offset[, noAssert])"></a>buf.writeDoubleLE(value, offset[, noAssert])</h3>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个有效的 64 位double 类型的值。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成value被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</li>
<li><h3 id="buf-writeDoubleBE-value-offset-noAssert"><a href="#buf-writeDoubleBE-value-offset-noAssert" class="headerlink" title="buf.writeDoubleBE(value, offset[, noAssert])"></a>buf.writeDoubleBE(value, offset[, noAssert])</h3>根据传入的 offset 偏移量和指定的 endian 格式将 value 写入 buffer。注意：value 必须是一个有效的 64 位double 类型的值。 若参数 noAssert 为 true 将不会验证 value 和 offset 偏移量参数。 这意味着 value 可能过大，或者 offset 可能会超出 buffer 的末尾从而造成value被丢弃。 除非你对这个参数非常有把握，否则尽量不要使用。默认是 false。</li>
<li><h3 id="buf-fill-value-offset-end"><a href="#buf-fill-value-offset-end" class="headerlink" title="buf.fill(value[, offset][, end])"></a>buf.fill(value[, offset][, end])</h3>使用指定的 value 来填充这个 buffer。如果没有指定 offset (默认是 0) 并且 end (默认是 buffer.length) ，将会填充整个buffer。</li>
</ul>
<hr>
<h1 id="Node-js-Stream-流"><a href="#Node-js-Stream-流" class="headerlink" title="Node.js Stream(流)"></a>Node.js Stream(流)</h1><h2 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h2><p>Stream 是一个抽象接口，Node 中有很多对象实现了这个接口。例如，对http 服务器发起请求的request 对象就是一个 Stream，还有stdout（标准输出）。<br>Node.js，Stream 有四种流类型：</p>
<ul>
<li>Readable - 可读操作。</li>
<li>Writable - 可写操作。</li>
<li>Duplex - 可读可写操作.</li>
<li>Transform - 操作被写入数据，然后读出结果。</li>
</ul>
<p>所有的 Stream 对象都是 EventEmitter 的实例。常用的事件有：</p>
<ul>
<li>data - 当有数据可读时触发。</li>
<li>end - 没有更多的数据可读时触发。</li>
<li>error - 在接收和写入过程中发生错误时触发。</li>
<li>finish - 所有数据已被写入到底层系统时触发。<br>本教程会为大家介绍常用的流操作。</li>
</ul>
<h2 id="从流中读取数据"><a href="#从流中读取数据" class="headerlink" title="从流中读取数据"></a>从流中读取数据</h2><p>创建 input.txt 文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">菜鸟教程官网地址：www.runoob.com</span><br></pre></td></tr></table></figure>
<p>创建 main.js 文件, 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line">var data &#x3D; &#39;&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建可读流</span><br><span class="line">var readerStream &#x3D; fs.createReadStream(&#39;input.txt&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置编码为 utf8。</span><br><span class="line">readerStream.setEncoding(&#39;UTF8&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理流事件 --&gt; data, end, and error</span><br><span class="line">readerStream.on(&#39;data&#39;, function(chunk) &#123;</span><br><span class="line">   data +&#x3D; chunk;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readerStream.on(&#39;end&#39;,function()&#123;</span><br><span class="line">   console.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">readerStream.on(&#39;error&#39;, function(err)&#123;</span><br><span class="line">   console.log(err.stack);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;程序执行完毕&quot;);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">程序执行完毕</span><br><span class="line">菜鸟教程官网地址：www.runoob.com</span><br></pre></td></tr></table></figure>

<h2 id="写入流"><a href="#写入流" class="headerlink" title="写入流"></a>写入流</h2><p>创建 main.js 文件, 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line">var data &#x3D; &#39;菜鸟教程官网地址：www.runoob.com&#39;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个可以写入的流，写入到文件 output.txt 中</span><br><span class="line">var writerStream &#x3D; fs.createWriteStream(&#39;output.txt&#39;);</span><br><span class="line">&#x2F;&#x2F;如果要追加写入 可以用代码 var writeStream &#x3D; fs.createWriteStream(&#39;out.txt&#39;, &#123; &#39;flags&#39;: &#39;a&#39; &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 utf8 编码写入数据</span><br><span class="line">writerStream.write(data,&#39;UTF8&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 标记文件末尾</span><br><span class="line">writerStream.end();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 处理流事件 --&gt; data, end, and error</span><br><span class="line">writerStream.on(&#39;finish&#39;, function() &#123;</span><br><span class="line">    console.log(&quot;写入完成。&quot;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">writerStream.on(&#39;error&#39;, function(err)&#123;</span><br><span class="line">   console.log(err.stack);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;程序执行完毕&quot;);</span><br></pre></td></tr></table></figure>
<p>以上程序会将 data 变量的数据写入到 output.txt 文件中。代码执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js </span><br><span class="line">程序执行完毕</span><br><span class="line">写入完成。</span><br></pre></td></tr></table></figure>
<p>查看 output.txt 文件的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cat output.txt </span><br><span class="line">菜鸟教程官网地址：www.runoob.com</span><br></pre></td></tr></table></figure>

<h2 id="管道流"><a href="#管道流" class="headerlink" title="管道流"></a>管道流</h2><p>以下实例我们通过读取一个文件内容并将内容写入到另外一个文件中。<br>设置 input.txt 文件内容如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">菜鸟教程官网地址：www.runoob.com</span><br><span class="line">管道流操作实例</span><br></pre></td></tr></table></figure>
<p>创建 main.js 文件, 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个可读流</span><br><span class="line">var readerStream &#x3D; fs.createReadStream(&#39;input.txt&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 创建一个可写流</span><br><span class="line">var writerStream &#x3D; fs.createWriteStream(&#39;output.txt&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 管道读写操作</span><br><span class="line">&#x2F;&#x2F; 读取 input.txt 文件内容，并将内容写入到 output.txt 文件中</span><br><span class="line">readerStream.pipe(writerStream);</span><br><span class="line"></span><br><span class="line">console.log(&quot;程序执行完毕&quot;);</span><br></pre></td></tr></table></figure>
<p>代码执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js </span><br><span class="line">程序执行完毕</span><br></pre></td></tr></table></figure>
<p>查看 output.txt 文件的内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ cat output.txt </span><br><span class="line">菜鸟教程官网地址：www.runoob.com</span><br><span class="line">管道流操作实例</span><br></pre></td></tr></table></figure>

<h2 id="链式流"><a href="#链式流" class="headerlink" title="链式流"></a>链式流</h2><p>链式是通过连接输出流到另外一个流并创建多个流操作链的机制。链式流一般用于管道操作。<br>接下来我们就是用管道和链式来压缩和解压文件。<br>创建 compress.js 文件, 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line">var zlib &#x3D; require(&#39;zlib&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 压缩 input.txt 文件为 input.txt.gz</span><br><span class="line">fs.createReadStream(&#39;input.txt&#39;)</span><br><span class="line">  .pipe(zlib.createGzip())</span><br><span class="line">  .pipe(fs.createWriteStream(&#39;input.txt.gz&#39;));</span><br><span class="line">  </span><br><span class="line">console.log(&quot;文件压缩完成。&quot;);</span><br></pre></td></tr></table></figure>
<p>代码执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node compress.js </span><br><span class="line">文件压缩完成。</span><br></pre></td></tr></table></figure>
<p>执行完以上操作后，我们可以看到当前目录下生成了 input.txt 的压缩文件 input.txt.gz。<br>接下来，让我们来解压该文件，创建 decompress.js 文件，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line">var zlib &#x3D; require(&#39;zlib&#39;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 解压 input.txt.gz 文件为 input.txt</span><br><span class="line">fs.createReadStream(&#39;input.txt.gz&#39;)</span><br><span class="line">  .pipe(zlib.createGunzip())</span><br><span class="line">  .pipe(fs.createWriteStream(&#39;input.txt&#39;));</span><br><span class="line">  </span><br><span class="line">console.log(&quot;文件解压完成。&quot;);</span><br></pre></td></tr></table></figure>
<p>代码执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node decompress.js </span><br><span class="line">文件解压完成。</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Node-js-函数"><a href="#Node-js-函数" class="headerlink" title="Node.js 函数"></a>Node.js 函数</h1><h2 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h2><p>在JavaScript中，一个函数可以作为另一个函数的参数。我们可以先定义一个函数，然后传递，也可以在传递参数的地方直接定义函数。<br>Node.js中函数的使用与Javascript类似，举例来说，你可以这样做：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function say(word) &#123;</span><br><span class="line">  console.log(word);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function execute(someFunction, value) &#123;</span><br><span class="line">  someFunction(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execute(say, &quot;Hello&quot;);</span><br></pre></td></tr></table></figure>
<p>以上代码中，我们把 say 函数作为execute函数的第一个变量进行了传递。这里传递的不是 say 的返回值，而是 say 本身！<br>这样一来， say 就变成了execute 中的本地变量 someFunction ，execute可以通过调用 someFunction() （带括号的形式）来使用 say 函数。<br>当然，因为 say 有一个变量， execute 在调用 someFunction 时可以传递这样一个变量。</p>
<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>我们可以把一个函数作为变量传递,此时我们将函数作为回调函数使用。但是我们不一定要绕这个”先定义，再传递”的圈子，我们可以直接在另一个函数的括号中定义和传递这个函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function execute(someFunction, value) &#123;</span><br><span class="line">  someFunction(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">execute(function(word)&#123; console.log(word) &#125;, &quot;Hello&quot;);</span><br></pre></td></tr></table></figure>
<p>我们在 execute 接受第一个参数的地方直接定义了我们准备传递给 execute 的函数。<br>用这种方式，我们甚至不用给这个函数起名字，这也是为什么它被叫做匿名函数 。</p>
<hr>
<h1 id="Node-js-路由"><a href="#Node-js-路由" class="headerlink" title="Node.js 路由"></a>Node.js 路由</h1><p>我们要为路由提供请求的 URL 和其他需要的 GET 及 POST 参数，随后路由需要根据这些数据来执行相应的代码。<br>因此，我们需要查看 HTTP 请求，从中提取出请求的 URL 以及 GET/POST 参数。这一功能应当属于路由还是服务器（甚至作为一个模块自身的功能）确实值得探讨，但这里暂定其为我们的HTTP服务器的功能。<br>我们需要的所有数据都会包含在 request 对象中，该对象作为 onRequest() 回调函数的第一个参数传递。但是为了解析这些数据，我们需要额外的 Node.JS 模块，它们分别是 url 和 querystring 模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">                   url.parse(string).query</span><br><span class="line">                                           |</span><br><span class="line">           url.parse(string).pathname      |</span><br><span class="line">                       |                   |</span><br><span class="line">                       |                   |</span><br><span class="line">                     ------ -------------------</span><br><span class="line">http:&#x2F;&#x2F;localhost:8888&#x2F;start?foo&#x3D;bar&amp;hello&#x3D;world</span><br><span class="line">                                ---       -----</span><br><span class="line">                                 |          |</span><br><span class="line">                                 |          |</span><br><span class="line">              querystring.parse(queryString)[&quot;foo&quot;]    |</span><br><span class="line">                                            |</span><br><span class="line">                         querystring.parse(queryString)[&quot;hello&quot;]</span><br></pre></td></tr></table></figure>
<p>当然我们也可以用 querystring 模块来解析 POST 请求体中的参数，稍后会有演示。<br>现在我们来在 <strong>server.js</strong> 文件中给 onRequest() 函数加上一些逻辑，用来找出浏览器请求的 URL 路径：</p>
<figure class="highlight plain"><figcaption><span>server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&quot;http&quot;);</span><br><span class="line">var url &#x3D; require(&quot;url&quot;);</span><br><span class="line"> </span><br><span class="line">function start() &#123;</span><br><span class="line">  function onRequest(request, response) &#123;</span><br><span class="line">    var pathname &#x3D; url.parse(request.url).pathname;</span><br><span class="line">    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);</span><br><span class="line">    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text&#x2F;plain&quot;&#125;);</span><br><span class="line">    response.write(&quot;Hello World&quot;);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  http.createServer(onRequest).listen(8888);</span><br><span class="line">  console.log(&quot;Server has started.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">exports.start &#x3D; start;</span><br></pre></td></tr></table></figure>
<p>好了，我们的应用现在可以通过请求的 URL 路径来区别不同请求了–这使我们得以使用路由（还未完成）来将请求以 URL 路径为基准映射到处理程序上。<br>在我们所要构建的应用中，这意味着来自 /start 和 /upload 的请求可以使用不同的代码来处理。稍后我们将看到这些内容是如何整合到一起的。<br>现在我们可以来编写路由了，建立一个名为 <strong>router.js</strong> 的文件，添加以下内容：</p>
<figure class="highlight plain"><figcaption><span>router.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function route(pathname) &#123;</span><br><span class="line">  console.log(&quot;About to route a request for &quot; + pathname);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">exports.route &#x3D; route;</span><br></pre></td></tr></table></figure>
<p>如你所见，这段代码什么也没干，不过对于现在来说这是应该的。在添加更多的逻辑以前，我们先来看看如何把路由和服务器整合起来。<br>我们的服务器应当知道路由的存在并加以有效利用。我们当然可以通过硬编码的方式将这一依赖项绑定到服务器上，但是其它语言的编程经验告诉我们这会是一件非常痛苦的事，因此我们将使用依赖注入的方式较松散地添加路由模块。<br>首先，我们来扩展一下服务器的 start() 函数，以便将路由函数作为参数传递过去，<strong>server.js</strong> 文件代码如下</p>
<figure class="highlight plain"><figcaption><span>server.js：</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&quot;http&quot;);</span><br><span class="line">var url &#x3D; require(&quot;url&quot;);</span><br><span class="line"> </span><br><span class="line">function start(route) &#123;</span><br><span class="line">  function onRequest(request, response) &#123;</span><br><span class="line">    var pathname &#x3D; url.parse(request.url).pathname;</span><br><span class="line">    console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);</span><br><span class="line"> </span><br><span class="line">    route(pathname);</span><br><span class="line"> </span><br><span class="line">    response.writeHead(200, &#123;&quot;Content-Type&quot;: &quot;text&#x2F;plain&quot;&#125;);</span><br><span class="line">    response.write(&quot;Hello World&quot;);</span><br><span class="line">    response.end();</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  http.createServer(onRequest).listen(8888);</span><br><span class="line">  console.log(&quot;Server has started.&quot;);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">exports.start &#x3D; start;</span><br></pre></td></tr></table></figure>
<p>同时，我们会相应扩展 <strong>index.js</strong>，使得路由函数可以被注入到服务器中：</p>
<figure class="highlight plain"><figcaption><span>index.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var server &#x3D; require(&quot;.&#x2F;server&quot;);</span><br><span class="line">var router &#x3D; require(&quot;.&#x2F;router&quot;);</span><br><span class="line"> </span><br><span class="line">server.start(router.route);</span><br></pre></td></tr></table></figure>
<p>在这里，我们传递的函数依旧什么也没做。<br>如果现在启动应用（<code>node index.js</code>，始终记得这个命令行），随后请求一个URL，你将会看到应用输出相应的信息，这表明我们的HTTP服务器已经在使用路由模块了，并会将请求的路径传递给路由：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node index.js</span><br><span class="line">Server has started.</span><br></pre></td></tr></table></figure>
<p>以上输出已经去掉了比较烦人的 /favicon.ico 请求相关的部分。<br>浏览器访问 <a href="http://127.0.0.1:8888/" target="_blank" rel="noopener">http://127.0.0.1:8888/</a>，输出结果如下：<br><img src="http://www.runoob.com/wp-content/uploads/2014/04/227B22AE-E633-4DCB-8740-AA51D32B8942.jpg" alt=""></p>
<hr>
<h1 id="Node-js-全局对象"><a href="#Node-js-全局对象" class="headerlink" title="Node.js 全局对象"></a>Node.js 全局对象</h1><h2 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h2><p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。<br>在浏览器 JavaScript 中，通常 window 是全局对象， 而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global 对象的属性。<br>在 Node.js 我们可以直接访问到 global 的属性，而不需要在应用中包含它。</p>
<h2 id="全局对象与全局变量"><a href="#全局对象与全局变量" class="headerlink" title="全局对象与全局变量"></a>全局对象与全局变量</h2><p>global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条 件的变量是全局变量：<br>在最外层定义的变量；<br>全局对象的属性；<br>隐式定义的变量（未定义直接赋值的变量）。<br>当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。需要注 意的是，在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的， 而模块本身不是最外层上下文。<br><strong>注意： 永远使用 var 定义变量以避免引入全局变量，因为全局变量会污染 命名空间，提高代码的耦合风险。</strong></p>
<h2 id="filename"><a href="#filename" class="headerlink" title="__filename"></a>__filename</h2><p>__filename 表示当前正在执行的脚本的文件名。它将输出文件所在位置的绝对路径，且和命令行参数所指定的文件名不一定相同。 如果在模块中，返回的值是模块文件的路径。</p>
<ul>
<li>实例<br>创建文件 main.js ，代码如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 输出全局变量 __filename 的值</span><br><span class="line">console.log( __filename );</span><br></pre></td></tr></table></figure>
执行 main.js 文件，代码如下所示:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">&#x2F;web&#x2F;com&#x2F;runoob&#x2F;nodejs&#x2F;main.js</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="dirname"><a href="#dirname" class="headerlink" title="__dirname"></a>__dirname</h2><p>__dirname 表示当前执行脚本所在的目录。</p>
<ul>
<li>实例<br>创建文件 main.js ，代码如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 输出全局变量 __dirname 的值</span><br><span class="line">console.log( __dirname );</span><br></pre></td></tr></table></figure>
执行 main.js 文件，代码如下所示:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">&#x2F;web&#x2F;com&#x2F;runoob&#x2F;nodejs</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="setTimeout-cb-ms"><a href="#setTimeout-cb-ms" class="headerlink" title="setTimeout(cb, ms)"></a>setTimeout(cb, ms)</h2><p>setTimeout(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。：setTimeout() 只执行一次指定函数。<br>返回一个代表定时器的句柄值。</p>
<ul>
<li>实例<br>创建文件 main.js ，代码如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function printHello()&#123;</span><br><span class="line">   console.log( &quot;Hello, World!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 两秒后执行以上函数</span><br><span class="line">setTimeout(printHello, 2000);</span><br></pre></td></tr></table></figure>
执行 main.js 文件，代码如下所示:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">Hello, World!</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="clearTimeout-t"><a href="#clearTimeout-t" class="headerlink" title="clearTimeout(t)"></a>clearTimeout(t)</h2><p>clearTimeout( t ) 全局函数用于停止一个之前通过 setTimeout() 创建的定时器。 参数 t 是通过 setTimeout() 函数创建的定时器。</p>
<ul>
<li>实例<br>创建文件 main.js ，代码如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function printHello()&#123;</span><br><span class="line">   console.log( &quot;Hello, World!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 两秒后执行以上函数</span><br><span class="line">var t &#x3D; setTimeout(printHello, 2000);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 清除定时器</span><br><span class="line">clearTimeout(t);</span><br></pre></td></tr></table></figure>
执行 main.js 文件，代码如下所示:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="setInterval-cb-ms"><a href="#setInterval-cb-ms" class="headerlink" title="setInterval(cb, ms)"></a>setInterval(cb, ms)</h2><p>setInterval(cb, ms) 全局函数在指定的毫秒(ms)数后执行指定函数(cb)。<br>返回一个代表定时器的句柄值。可以使用 clearInterval(t) 函数来清除定时器。<br>setInterval() 方法会不停地调用函数，直到 clearInterval() 被调用或窗口被关闭。<br>实例<br>创建文件 main.js ，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function printHello()&#123;</span><br><span class="line">   console.log( &quot;Hello, World!&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 两秒后执行以上函数</span><br><span class="line">setInterval(printHello, 2000);</span><br></pre></td></tr></table></figure>
<p>执行 main.js 文件，代码如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js </span><br><span class="line">Hello, World! Hello, World! Hello, World! Hello, World! Hello, World! ……</span><br></pre></td></tr></table></figure>
<p>以上程序每隔两秒就会输出一次”Hello, World!”，且会永久执行下去，直到你按下 ctrl + c 按钮。</p>
<h2 id="console"><a href="#console" class="headerlink" title="console"></a>console</h2><p>console 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的实施标准。<br>Node.js 沿用了这个标准，提供与习惯行为一致的 console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符。<br><strong>console 方法</strong><br>以下为 console 对象的方法:</p>
<h3 id="console-log-data-…"><a href="#console-log-data-…" class="headerlink" title="console.log([data][, …])"></a>console.log([data][, …])</h3><p>向标准输出流打印字符并以换行符结束。该方法接收若干个参数，如果只有一个参数，则输出这个参数的字符串形式。如果有多个参数，则 以类似于C 语言 printf() 命令的格式输出。<br>第一个参数是一个字符串，如果没有 参数，只打印一个换行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;Hello world&#39;); </span><br><span class="line">console.log(&#39;byvoid%diovyb&#39;); </span><br><span class="line">console.log(&#39;byvoid%diovyb&#39;, 1991);</span><br></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Hello world </span><br><span class="line">byvoid%diovyb </span><br><span class="line">byvoid1991iovyb</span><br></pre></td></tr></table></figure>

<h3 id="console-info-data-…"><a href="#console-info-data-…" class="headerlink" title="console.info([data][, …])"></a>console.info([data][, …])</h3><p>该命令的作用是返回信息性消息，这个命令与console.log差别并不大，除了在chrome中只会输出文字外，其余的会显示一个蓝色的惊叹号。</p>
<h3 id="console-error-data-…"><a href="#console-error-data-…" class="headerlink" title="console.error([data][, …])"></a>console.error([data][, …])</h3><p>输出错误消息的。控制台在出现错误时会显示是红色的叉子。与console.log() 用法相同，只是向标准错误流输出。</p>
<h3 id="console-warn-data-…"><a href="#console-warn-data-…" class="headerlink" title="console.warn([data][, …])"></a>console.warn([data][, …])</h3><p>输出警告消息。控制台出现有黄色的惊叹号。</p>
<h3 id="console-dir-obj-options"><a href="#console-dir-obj-options" class="headerlink" title="console.dir(obj[, options])"></a>console.dir(obj[, options])</h3><p>用来对一个对象进行检查（inspect），并以易于阅读和打印的格式显示。</p>
<h3 id="console-time-label"><a href="#console-time-label" class="headerlink" title="console.time(label)"></a>console.time(label)</h3><p>输出时间，表示计时开始。</p>
<h3 id="console-timeEnd-label"><a href="#console-timeEnd-label" class="headerlink" title="console.timeEnd(label)"></a>console.timeEnd(label)</h3><p>结束时间，表示计时结束。</p>
<h3 id="console-trace-message-…"><a href="#console-trace-message-…" class="headerlink" title="console.trace(message[, …])"></a>console.trace(message[, …])</h3><p>当前执行的代码在堆栈中的调用路径，这个测试函数运行很有帮助，只要给想测试的函数里面加入 console.trace 就行了。向标准错误流输出当前的调用栈。</p>
<h3 id="console-assert-value-message-…"><a href="#console-assert-value-message-…" class="headerlink" title="console.assert(value[, message][, …])"></a>console.assert(value[, message][, …])</h3><p>用于判断某个表达式或变量是否为真，接收两个参数，第一个参数是表达式，第二个参数是字符串。只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。</p>
<h3 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h3><p>创建文件 main.js ，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">console.info(&quot;程序开始执行：&quot;);</span><br><span class="line"></span><br><span class="line">var counter &#x3D; 10;</span><br><span class="line">console.log(&quot;计数: %d&quot;, counter);</span><br><span class="line"></span><br><span class="line">console.time(&quot;获取数据&quot;);</span><br><span class="line">&#x2F;&#x2F;</span><br><span class="line">&#x2F;&#x2F; 执行一些代码</span><br><span class="line">&#x2F;&#x2F; </span><br><span class="line">console.timeEnd(&#39;获取数据&#39;);</span><br><span class="line"></span><br><span class="line">console.info(&quot;程序执行完毕。&quot;)</span><br></pre></td></tr></table></figure>
<p>执行 main.js 文件，代码如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">程序开始执行：</span><br><span class="line">计数: 10</span><br><span class="line">获取数据: 0ms</span><br><span class="line">程序执行完毕</span><br></pre></td></tr></table></figure>

<h2 id="process"><a href="#process" class="headerlink" title="process"></a>process</h2><p>process 是一个全局变量，即 global 对象的属性。<br>它用于描述当前Node.js 进程状态的对象，提供了一个与操作系统的简单接口。通常在你写本地命令行程序的时候，少不了要和它打交道。下面将会介绍 process 对象的一些最常用的成员方法。</p>
<ul>
<li><strong>exit</strong><br>当进程准备退出时触发</li>
<li><strong>beforeExit</strong><br>当 node 清空事件循环，并且没有其他安排时触发这个事件。通常来说，当没有进程安排时 node 退出，但是 ‘beforeExit’ 的监听器可以异步调用，这样 node 就会继续执行。</li>
<li><strong>uncaughtException</strong><br>当一个异常冒泡回到事件循环，触发这个事件。如果给异常添加了监视器，默认的操作（打印堆栈跟踪信息并退出）就不会发生。</li>
<li><strong>Signal 事件</strong><br>当进程接收到信号时就触发。信号列表详见标准的 POSIX 信号名，如 SIGINT、SIGUSR1 等。</li>
</ul>
<p><strong>实例</strong><br>创建文件 main.js ，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">process.on(&#39;exit&#39;, function(code) &#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 以下代码永远不会执行</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    console.log(&quot;该代码不会执行&quot;);</span><br><span class="line">  &#125;, 0);</span><br><span class="line">  </span><br><span class="line">  console.log(&#39;退出码为:&#39;, code);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(&quot;程序执行结束&quot;);</span><br></pre></td></tr></table></figure>
<p>执行 main.js 文件，代码如下所示:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">程序执行结束</span><br><span class="line">退出码为: 0</span><br></pre></td></tr></table></figure>

<h3 id="退出状态码"><a href="#退出状态码" class="headerlink" title="退出状态码"></a>退出状态码</h3><p>1.<strong>Uncaught Fatal Exception</strong><br>有未捕获异常，并且没有被域或 uncaughtException 处理函数处理。</p>
<p>2.<strong>Unused</strong><br>保留</p>
<p>3.<strong>Internal JavaScript Parse Error</strong><br>JavaScript的源码启动 Node 进程时引起解析错误。非常罕见，仅会在开发 Node 时才会有。</p>
<p>4.<strong>Internal JavaScript Evaluation Failure</strong><br>JavaScript 的源码启动 Node 进程，评估时返回函数失败。非常罕见，仅会在开发 Node 时才会有。</p>
<p>5.<strong>Fatal Error</strong><br>V8 里致命的不可恢复的错误。通常会打印到 stderr ，内容为： FATAL ERROR</p>
<p>6.<strong>Non-function Internal Exception Handler</strong><br>未捕获异常，内部异常处理函数不知为何设置为on-function，并且不能被调用。</p>
<p>7.<strong>Internal Exception Handler Run-Time Failure</strong><br>未捕获的异常， 并且异常处理函数处理时自己抛出了异常。例如，如果 process.on(‘uncaughtException’) 或 domain.on(‘error’) 抛出了异常。</p>
<p>8.<strong>Unused</strong><br>保留</p>
<p>9.<strong>Invalid Argument</strong><br>可能是给了未知的参数，或者给的参数没有值。</p>
<p>10.<strong>Internal JavaScript Run-Time Failure</strong><br>JavaScript的源码启动 Node 进程时抛出错误，非常罕见，仅会在开发 Node 时才会有。</p>
<p> 12.<strong>Invalid Debug Argument</strong><br>设置了参数–debug 和/或 –debug-brk，但是选择了错误端口。</p>
<p> 128.<strong>Signal Exits</strong><br>如果 Node 接收到致命信号，比如SIGKILL 或 SIGHUP，那么退出代码就是128 加信号代码。这是标准的 Unix 做法，退出信号代码放在高位。</p>
<h3 id="Process-属性"><a href="#Process-属性" class="headerlink" title="Process 属性"></a>Process 属性</h3><p>Process 提供了很多有用的属性，便于我们更好的控制系统的交互：</p>
<ol>
<li><strong>stdout</strong><br>标准输出流。</li>
<li><strong>stderr</strong><br>标准错误流。</li>
<li><strong>stdin</strong><br>标准输入流。</li>
<li><strong>argv</strong><br>argv 属性返回一个数组，由命令行执行脚本时的各个参数组成。它的第一个成员总是node，第二个成员是脚本文件名，其余成员是脚本文件的参数。</li>
<li><strong>execPath</strong><br>返回执行当前脚本的 Node 二进制文件的绝对路径。</li>
<li><strong>execArgv</strong><br>返回一个数组，成员是命令行下执行脚本时，在Node可执行文件与脚本文件之间的命令行参数。</li>
<li><strong>env</strong><br>返回一个对象，成员为当前 shell 的环境变量</li>
<li><strong>exitCode</strong><br>进程退出时的代码，如果进程优通过 process.exit() 退出，不需要指定退出码。</li>
<li><strong>version</strong><br>Node 的版本，比如v0.10.18。</li>
<li><strong>versions</strong><br>一个属性，包含了 node 的版本和依赖.</li>
<li><strong>config</strong><br>一个包含用来编译当前 node 执行文件的 javascript 配置选项的对象。它与运行 ./configure 脚本生成的 “config.gypi” 文件相同。</li>
<li><strong>pid</strong><br>当前进程的进程号。</li>
<li><strong>title</strong><br>进程名，默认值为”node”，可以自定义该值。</li>
<li><strong>arch</strong><br>当前 CPU 的架构：’arm’、’ia32’ 或者 ‘x64’。</li>
<li><strong>platform</strong><br>运行程序所在的平台系统 ‘darwin’, ‘freebsd’, ‘linux’, ‘sunos’ 或 ‘win32’</li>
<li><strong>mainModule</strong><br>require.main 的备选方法。不同点，如果主模块在运行时改变，require.main可能会继续返回老的模块。可以认为，这两者引用了同一个模块。</li>
</ol>
<ul>
<li>实例<br>创建文件 main.js ，代码如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 输出到终端</span><br><span class="line">process.stdout.write(&quot;Hello World!&quot; + &quot;\n&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 通过参数读取</span><br><span class="line">process.argv.forEach(function(val, index, array) &#123;</span><br><span class="line">   console.log(index + &#39;: &#39; + val);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取执行路径</span><br><span class="line">console.log(process.execPath);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 平台信息</span><br><span class="line">console.log(process.platform);</span><br></pre></td></tr></table></figure>
执行 main.js 文件，代码如下所示:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">Hello World!</span><br><span class="line">0: node</span><br><span class="line">1: &#x2F;web&#x2F;www&#x2F;node&#x2F;main.js</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;node&#x2F;0.10.36&#x2F;bin&#x2F;node</span><br><span class="line">darwin</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="方法参考手册"><a href="#方法参考手册" class="headerlink" title="方法参考手册"></a>方法参考手册</h3><ol>
<li><strong>abort()</strong><br>这将导致 node 触发 abort 事件。会让 node 退出并生成一个核心文件。</li>
<li><strong>chdir(directory)</strong><br>改变当前工作进程的目录，如果操作失败抛出异常。</li>
<li><strong>cwd()</strong><br>返回当前进程的工作目录</li>
<li><strong>exit([code])</strong><br>使用指定的 code 结束进程。如果忽略，将会使用 code 0。</li>
<li><strong>getgid()</strong><br>获取进程的群组标识（参见 getgid(2)）。获取到得时群组的数字 id，而不是名字。<br>注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</li>
<li><strong>setgid(id)</strong><br>设置进程的群组标识（参见 setgid(2)）。可以接收数字 ID 或者群组名。如果指定了群组名，会阻塞等待解析为数字 ID 。<br>注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</li>
<li><strong>getuid()</strong><br>获取进程的用户标识(参见 getuid(2))。这是数字的用户 id，不是用户名。<br>注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</li>
<li><strong>setuid(id)</strong><br>设置进程的用户标识（参见setuid(2)）。接收数字 ID或字符串名字。果指定了群组名，会阻塞等待解析为数字 ID 。<br>注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</li>
<li><strong>getgroups()</strong><br>返回进程的群组 iD 数组。POSIX 系统没有保证一定有，但是 node.js 保证有。<br>注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</li>
<li><strong>setgroups(groups)</strong><br>设置进程的群组 ID。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。<br>注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</li>
<li><strong>initgroups(user, extra_group)</strong><br>读取 /etc/group ，并初始化群组访问列表，使用成员所在的所有群组。这是授权操作，所以你需要有 root 权限，或者有 CAP_SETGID 能力。<br>注意：这个函数仅在 POSIX 平台上可用(例如，非Windows 和 Android)。</li>
<li><strong>kill(pid[, signal])</strong><br>发送信号给进程. pid 是进程id，并且 signal 是发送的信号的字符串描述。信号名是字符串，比如 ‘SIGINT’ 或 ‘SIGHUP’。如果忽略，信号会是 ‘SIGTERM’。</li>
<li><strong>memoryUsage()</strong><br>返回一个对象，描述了 Node 进程所用的内存状况，单位为字节。</li>
<li><strong>nextTick(callback)</strong><br>一旦当前事件循环结束，调用回调函数。</li>
<li><strong>umask([mask])</strong><br>设置或读取进程文件的掩码。子进程从父进程继承掩码。如果mask 参数有效，返回旧的掩码。否则，返回当前掩码。</li>
<li><strong>uptime()</strong><br>返回 Node 已经运行的秒数。</li>
<li><strong>hrtime()</strong><br>返回当前进程的高分辨时间，形式为 [seconds, nanoseconds]数组。它是相对于过去的任意事件。该值与日期无关，因此不受时钟漂移的影响。主要用途是可以通过精确的时间间隔，来衡量程序的性能。<br>你可以将之前的结果传递给当前的 process.hrtime() ，会返回两者间的时间差，用来基准和测量时间间隔。</li>
</ol>
<ul>
<li>实例<br>创建文件 main.js ，代码如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 输出当前目录</span><br><span class="line">console.log(&#39;当前目录: &#39; + process.cwd());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出当前版本</span><br><span class="line">console.log(&#39;当前版本: &#39; + process.version);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 输出内存使用情况</span><br><span class="line">console.log(process.memoryUsage());</span><br></pre></td></tr></table></figure>
执行 main.js 文件，代码如下所示:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node main.js</span><br><span class="line">当前目录: &#x2F;web&#x2F;com&#x2F;runoob&#x2F;nodejs</span><br><span class="line">当前版本: v0.10.36</span><br><span class="line">&#123; rss: 12541952, heapTotal: 4083456, heapUsed: 2157056 &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<hr>
<h1 id="Node-js-util模块"><a href="#Node-js-util模块" class="headerlink" title="Node.js util模块"></a>Node.js util模块</h1><p><a href="https://nodejs.org/api/util.html" target="_blank" rel="noopener">官方文档</a></p>
<p>util 是一个Node.js 核心模块，提供常用函数的集合，用于弥补核心JavaScript 的功能过于精简的不足。</p>
<h2 id="util-inherits"><a href="#util-inherits" class="headerlink" title="util.inherits"></a>util.inherits</h2><p><strong>util.inherits(constructor, superConstructor)</strong>是一个实现对象间原型继承 的函数。<br>JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。JavaScript 没有 提供对象继承的语言级别特性，而是通过原型复制来实现的。<br>在这里我们只介绍util.inherits 的用法，示例如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var util &#x3D; require(&#39;util&#39;); </span><br><span class="line">function Base() &#123; </span><br><span class="line">    this.name &#x3D; &#39;base&#39;; </span><br><span class="line">    this.base &#x3D; 1991; </span><br><span class="line">    this.sayHello &#x3D; function() &#123; </span><br><span class="line">    console.log(&#39;Hello &#39; + this.name); </span><br><span class="line">    &#125;; </span><br><span class="line">&#125; </span><br><span class="line">Base.prototype.showName &#x3D; function() &#123; </span><br><span class="line">    console.log(this.name);</span><br><span class="line">&#125;; </span><br><span class="line">function Sub() &#123; </span><br><span class="line">    this.name &#x3D; &#39;sub&#39;; </span><br><span class="line">&#125; </span><br><span class="line">util.inherits(Sub, Base); </span><br><span class="line">var objBase &#x3D; new Base(); </span><br><span class="line">objBase.showName(); </span><br><span class="line">objBase.sayHello(); </span><br><span class="line">console.log(objBase); </span><br><span class="line">var objSub &#x3D; new Sub(); </span><br><span class="line">objSub.showName(); </span><br><span class="line">&#x2F;&#x2F;objSub.sayHello(); </span><br><span class="line">console.log(objSub);</span><br></pre></td></tr></table></figure>
<p>我们定义了一个基础对象Base 和一个继承自Base 的Sub，Base 有三个在构造函数 内定义的属性和一个原型中定义的函数，通过util.inherits 实现继承。运行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">base </span><br><span class="line">Hello base </span><br><span class="line">&#123; name: &#39;base&#39;, base: 1991, sayHello: [Function] &#125; </span><br><span class="line">sub </span><br><span class="line">&#123; name: &#39;sub&#39; &#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：Sub 仅仅继承了Base 在原型中定义的函数，而构造函数内部创造的 base 属 性和 sayHello 函数都没有被 Sub 继承。同时，在原型中定义的属性不会被console.log 作 为对象的属性输出。</strong>如果我们去掉 objSub.sayHello(); 这行的注释，将会看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">node.js:201 </span><br><span class="line">throw e; &#x2F;&#x2F; process.nextTick error, or &#39;error&#39; event on first tick </span><br><span class="line">^ </span><br><span class="line">TypeError: Object #&lt;Sub&gt; has no method &#39;sayHello&#39; </span><br><span class="line">at Object.&lt;anonymous&gt; (&#x2F;home&#x2F;byvoid&#x2F;utilinherits.js:29:8) </span><br><span class="line">at Module._compile (module.js:441:26) </span><br><span class="line">at Object..js (module.js:459:10) </span><br><span class="line">at Module.load (module.js:348:31) </span><br><span class="line">at Function._load (module.js:308:12) </span><br><span class="line">at Array.0 (module.js:479:10) </span><br><span class="line">at EventEmitter._tickCallback (node.js:192:40)</span><br></pre></td></tr></table></figure>

<h2 id="util-inspect"><a href="#util-inspect" class="headerlink" title="util.inspect"></a>util.inspect</h2><p><strong>util.inspect(object,[showHidden],[depth],[colors])</strong>是一个将任意对象转换为字符串的方法，通常用于调试和错误输出。它至少接受一个参数 object，即要转换的对象。<br>showHidden 是一个可选参数，如果值为 true，将会输出更多隐藏信息。<br>depth 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多 少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。 如果color 值为 true，输出格式将会以ANSI 颜色编码，通常用于在终端显示更漂亮 的效果。<br>特别要指出的是，util.inspect 并不会简单地直接把对象转换为字符串，即使该对 象定义了toString 方法也不会调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var util &#x3D; require(&#39;util&#39;); </span><br><span class="line">function Person() &#123; </span><br><span class="line">    this.name &#x3D; &#39;byvoid&#39;; </span><br><span class="line">    this.toString &#x3D; function() &#123; </span><br><span class="line">    return this.name; </span><br><span class="line">    &#125;; </span><br><span class="line">&#125; </span><br><span class="line">var obj &#x3D; new Person(); </span><br><span class="line">console.log(util.inspect(obj)); </span><br><span class="line">console.log(util.inspect(obj, true));</span><br></pre></td></tr></table></figure>
<p>运行结果是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person &#123; name: &#39;byvoid&#39;, toString: [Function] &#125;</span><br><span class="line">Person &#123;</span><br><span class="line">  name: &#39;byvoid&#39;,</span><br><span class="line">  toString: </span><br><span class="line">   &#123; [Function]</span><br><span class="line">     [length]: 0,</span><br><span class="line">     [name]: &#39;&#39;,</span><br><span class="line">     [arguments]: null,</span><br><span class="line">     [caller]: null,</span><br><span class="line">     [prototype]: &#123; [constructor]: [Circular] &#125; &#125; &#125;</span><br></pre></td></tr></table></figure>

<h2 id="util-isArray-object"><a href="#util-isArray-object" class="headerlink" title="util.isArray(object)"></a>util.isArray(object)</h2><p>如果给定的参数 “object” 是一个数组返回true，否则返回false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var util &#x3D; require(&#39;util&#39;);</span><br><span class="line"></span><br><span class="line">util.isArray([])</span><br><span class="line">  &#x2F;&#x2F; true</span><br><span class="line">util.isArray(new Array)</span><br><span class="line">  &#x2F;&#x2F; true</span><br><span class="line">util.isArray(&#123;&#125;)</span><br><span class="line">  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h2 id="util-isRegExp-object"><a href="#util-isRegExp-object" class="headerlink" title="util.isRegExp(object)"></a>util.isRegExp(object)</h2><p>如果给定的参数 “object” 是一个正则表达式返回true，否则返回false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var util &#x3D; require(&#39;util&#39;);</span><br><span class="line"></span><br><span class="line">util.isRegExp(&#x2F;some regexp&#x2F;)</span><br><span class="line">  &#x2F;&#x2F; true</span><br><span class="line">util.isRegExp(new RegExp(&#39;another regexp&#39;))</span><br><span class="line">  &#x2F;&#x2F; true</span><br><span class="line">util.isRegExp(&#123;&#125;)</span><br><span class="line">  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h2 id="util-isDate-object"><a href="#util-isDate-object" class="headerlink" title="util.isDate(object)"></a>util.isDate(object)</h2><p>如果给定的参数 “object” 是一个日期返回true，否则返回false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var util &#x3D; require(&#39;util&#39;);</span><br><span class="line"></span><br><span class="line">util.isDate(new Date())</span><br><span class="line">  &#x2F;&#x2F; true</span><br><span class="line">util.isDate(Date())</span><br><span class="line">  &#x2F;&#x2F; false (without &#39;new&#39; returns a String)</span><br><span class="line">util.isDate(&#123;&#125;)</span><br><span class="line">  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h2 id="util-isError-object"><a href="#util-isError-object" class="headerlink" title="util.isError(object)"></a>util.isError(object)</h2><p>如果给定的参数 “object” 是一个错误对象返回true，否则返回false。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var util &#x3D; require(&#39;util&#39;);</span><br><span class="line"></span><br><span class="line">util.isError(new Error())</span><br><span class="line">  &#x2F;&#x2F; true</span><br><span class="line">util.isError(new TypeError())</span><br><span class="line">  &#x2F;&#x2F; true</span><br><span class="line">util.isError(&#123; name: &#39;Error&#39;, message: &#39;an error occurred&#39; &#125;)</span><br><span class="line">  &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Node-js-文件系统"><a href="#Node-js-文件系统" class="headerlink" title="Node.js 文件系统"></a>Node.js 文件系统</h1><p><a href="https://nodejs.org/api/fs.html#fs_fs_rename_oldpath_newpath_callback" target="_blank" rel="noopener">官方文档</a></p>
<h2 id="异步和同步"><a href="#异步和同步" class="headerlink" title="异步和同步"></a>异步和同步</h2><p>Node.js 文件系统（fs 模块）模块中的方法均有异步和同步版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的 fs.readFileSync()。<br>异步的方法函数最后一个参数为回调函数，回调函数的第一个参数包含了错误信息(error)。<br>建议大家使用异步方法，比起同步，异步方法性能更高，速度更快，而且没有阻塞。<br>实例</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">创建 input.txt 文件，内容如下：</span><br><span class="line">菜鸟教程官网地址：www.runoob.com</span><br><span class="line">文件读取实例</span><br></pre></td></tr></table></figure>
<p>创建 file.js 文件, 代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 异步读取</span><br><span class="line">fs.readFile(&#39;input.txt&#39;, function (err, data) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;异步读取: &quot; + data.toString());</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 同步读取</span><br><span class="line">var data &#x3D; fs.readFileSync(&#39;input.txt&#39;);</span><br><span class="line">console.log(&quot;同步读取: &quot; + data.toString());</span><br><span class="line"></span><br><span class="line">console.log(&quot;程序执行完毕。&quot;);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">同步读取: 菜鸟教程官网地址：www.runoob.com</span><br><span class="line">文件读取实例</span><br><span class="line"></span><br><span class="line">程序执行完毕。</span><br><span class="line">异步读取: 菜鸟教程官网地址：www.runoob.com</span><br><span class="line">文件读取实例</span><br></pre></td></tr></table></figure>
<p>接下来，让我们来具体了解下 Node.js 文件系统的方法。</p>
<h2 id="打开文件"><a href="#打开文件" class="headerlink" title="打开文件"></a>打开文件</h2><ul>
<li><p>语法<br>以下为在异步模式下打开文件的语法格式：<br><code>fs.open(path, flags[, mode], callback)</code></p>
</li>
<li><p>参数<br>参数使用说明如下：</p>
</li>
<li><p><em>path*</em> - 文件的路径。</p>
</li>
<li><p><em>flags*</em> - 文件打开的行为。具体值详见下文。</p>
</li>
<li><p><em>mode*</em> - 设置文件模式(权限)，文件创建默认权限为 0666(可读，可写)。</p>
</li>
<li><p><em>callback*</em> - 回调函数，带有两个参数如：callback(err, fd)。</p>
<p>flags 参数可以是以下值：<br><strong>r</strong>    以读取模式打开文件。如果文件不存在抛出异常。<br><strong>r+</strong>    以读写模式打开文件。如果文件不存在抛出异常。<br><strong>rs</strong>    以同步的方式读取文件。<br><strong>rs+</strong>    以同步的方式读取和写入文件。<br><strong>w</strong>    以写入模式打开文件，如果文件不存在则创建。<br><strong>wx</strong>    类似 ‘w’，但是如果文件路径存在，则文件写入失败。<br><strong>w+</strong>    以读写模式打开文件，如果文件不存在则创建。<br><strong>wx+</strong>    类似 ‘w+’， 但是如果文件路径存在，则文件读写失败。<br><strong>a</strong>    以追加模式打开文件，如果文件不存在则创建。<br><strong>ax</strong>    类似 ‘a’， 但是如果文件路径存在，则文件追加失败。<br><strong>a+</strong>    以读取追加模式打开文件，如果文件不存在则创建。<br><strong>ax+</strong>    类似 ‘a+’， 但是如果文件路径存在，则文件读取追加失败。</p>
</li>
<li><p>实例<br>接下来我们创建 file.js 文件，并打开 input.txt 文件进行读写，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 异步打开文件</span><br><span class="line">console.log(&quot;准备打开文件！&quot;);</span><br><span class="line">fs.open(&#39;input.txt&#39;, &#39;r+&#39;, function(err, fd) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">  console.log(&quot;文件打开成功！&quot;);     </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">准备打开文件！</span><br><span class="line">文件打开成功！</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h2><ul>
<li><p>语法<br>以下为通过异步模式获取文件信息的语法格式：<br><code>fs.stat(path, callback)</code></p>
</li>
<li><p>参数<br>参数使用说明如下：</p>
</li>
<li><p><em>path*</em> - 文件路径。</p>
</li>
<li><p><em>callback*</em> - 回调函数，带有两个参数如：(err, stats), stats 是 fs.Stats 对象。<br>fs.stat(path)执行后，会将stats类的实例返回给其回调函数。可以通过stats类中的提供方法判断文件的相关属性。例如判断是否为文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line"></span><br><span class="line">fs.stat(&#39;&#x2F;Users&#x2F;liuht&#x2F;code&#x2F;itbilu&#x2F;demo&#x2F;fs.js&#39;, function (err, stats) &#123;</span><br><span class="line">    console.log(stats.isFile());         &#x2F;&#x2F;true</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>stats类中的方法有：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>stats.isFile()</td>
<td>如果是文件返回 true，否则返回 false。</td>
</tr>
<tr>
<td>stats.isDirectory()</td>
<td>如果是目录返回 true，否则返回 false。</td>
</tr>
<tr>
<td>stats.isBlockDevice()</td>
<td>如果是块设备返回 true，否则返回 false。</td>
</tr>
<tr>
<td>stats.isCharacterDevice()</td>
<td>如果是字符设备返回 true，否则返回 false。</td>
</tr>
<tr>
<td>stats.isSymbolicLink()</td>
<td>如果是软链接返回 true，否则返回 false。</td>
</tr>
<tr>
<td>stats.isFIFO()</td>
<td>如果是FIFO，返回true，否则返回 false。FIFO是UNIX中的一种特殊类型的命令管道。</td>
</tr>
<tr>
<td>stats.isSocket()</td>
<td>如果是 Socket 返回 true，否则返回 false。</td>
</tr>
</tbody></table>
</li>
<li><p>实例<br>接下来我们创建 file.js 文件，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;准备打开文件！&quot;);</span><br><span class="line">fs.stat(&#39;input.txt&#39;, function (err, stats) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(stats);</span><br><span class="line">   console.log(&quot;读取文件信息成功！&quot;);</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 检测文件类型</span><br><span class="line">   console.log(&quot;是否为文件(isFile) ? &quot; + stats.isFile());</span><br><span class="line">   console.log(&quot;是否为目录(isDirectory) ? &quot; + stats.isDirectory());    </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">准备打开文件！</span><br><span class="line">&#123; dev: 16777220,</span><br><span class="line">  mode: 33188,</span><br><span class="line">  nlink: 1,</span><br><span class="line">  uid: 501,</span><br><span class="line">  gid: 20,</span><br><span class="line">  rdev: 0,</span><br><span class="line">  blksize: 4096,</span><br><span class="line">  ino: 40333161,</span><br><span class="line">  size: 61,</span><br><span class="line">  blocks: 8,</span><br><span class="line">  atime: Mon Sep 07 2015 17:43:55 GMT+0800 (CST),</span><br><span class="line">  mtime: Mon Sep 07 2015 17:22:35 GMT+0800 (CST),</span><br><span class="line">  ctime: Mon Sep 07 2015 17:22:35 GMT+0800 (CST) &#125;</span><br><span class="line">读取文件信息成功！</span><br><span class="line">是否为文件(isFile) ? true</span><br><span class="line">是否为目录(isDirectory) ? false</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="写入文件"><a href="#写入文件" class="headerlink" title="写入文件"></a>写入文件</h2><ul>
<li><p>语法<br>以下为异步模式下写入文件的语法格式：<br><code>fs.writeFile(file, data[, options], callback)</code><br>writeFile 直接打开文件默认是 w 模式，所以如果文件存在，该方法写入的内容会覆盖旧的文件内容。</p>
</li>
<li><p>参数<br>参数使用说明如下：</p>
</li>
<li><p><em>file*</em> - 文件名或文件描述符。</p>
</li>
<li><p><em>data*</em> - 要写入文件的数据，可以是 String(字符串) 或 Buffer(缓冲) 对象。</p>
</li>
<li><p><em>options*</em> - 该参数是一个对象，包含 {encoding, mode, flag}。默认编码为 utf8, 模式为 0666 ， flag 为 ‘w’</p>
</li>
<li><p><em>callback*</em> - 回调函数，回调函数只包含错误信息参数(err)，在写入失败时返回。</p>
</li>
<li><p>实例<br>接下来我们创建 file.js 文件，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;准备写入文件&quot;);</span><br><span class="line">fs.writeFile(&#39;input.txt&#39;, &#39;我是通过fs.writeFile 写入文件的内容&#39;,  function(err) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;数据写入成功！&quot;);</span><br><span class="line">   console.log(&quot;--------我是分割线-------------&quot;)</span><br><span class="line">   console.log(&quot;读取写入的数据！&quot;);</span><br><span class="line">   fs.readFile(&#39;input.txt&#39;, function (err, data) &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">         return console.error(err);</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(&quot;异步读取文件数据: &quot; + data.toString());</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上代码执行结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">准备写入文件</span><br><span class="line">数据写入成功！</span><br><span class="line">--------我是分割线-------------</span><br><span class="line">读取写入的数据！</span><br><span class="line">异步读取文件数据: 我是通过fs.writeFile 写入文件的内容</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h2><ul>
<li>语法<br>以下为异步模式下读取文件的语法格式：<br><code>fs.read(fd, buffer, offset, length, position, callback)</code><br>该方法使用了文件描述符来读取文件。</li>
<li>参数<br>参数使用说明如下：</li>
<li><em>fd*</em> - 通过 fs.open() 方法返回的文件描述符。</li>
<li><em>buffer*</em> - 数据写入的缓冲区。</li>
<li><em>offset*</em> - 缓冲区写入的写入偏移量。</li>
<li><em>length*</em> - 要从文件中读取的字节数。</li>
<li><em>position*</em> - 文件读取的起始位置，如果 position 的值为 null，则会从当前文件指针的位置读取。</li>
<li><em>callback*</em> - 回调函数，有三个参数err, bytesRead, buffer，err 为错误信息， bytesRead 表示读取的字节数，buffer 为缓冲区对象。</li>
<li>实例<br>input.txt 文件内容为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">菜鸟教程官网地址：www.runoob.com</span><br><span class="line">接下来我们创建 file.js 文件，代码如下所示：</span><br><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line">var buf &#x3D; new Buffer.alloc(1024);</span><br><span class="line"></span><br><span class="line">console.log(&quot;准备打开已存在的文件！&quot;);</span><br><span class="line">fs.open(&#39;input.txt&#39;, &#39;r+&#39;, function(err, fd) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;文件打开成功！&quot;);</span><br><span class="line">   console.log(&quot;准备读取文件：&quot;);</span><br><span class="line">   fs.read(fd, buf, 0, buf.length, 0, function(err, bytes)&#123;</span><br><span class="line">      if (err)&#123;</span><br><span class="line">         console.log(err);</span><br><span class="line">      &#125;</span><br><span class="line">      console.log(bytes + &quot;  字节被读取&quot;);</span><br><span class="line">      </span><br><span class="line">      &#x2F;&#x2F; 仅输出读取的字节</span><br><span class="line">      if(bytes &gt; 0)&#123;</span><br><span class="line">         console.log(buf.slice(0, bytes).toString());</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
以上代码执行结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">准备打开已存在的文件！</span><br><span class="line">文件打开成功！</span><br><span class="line">准备读取文件：</span><br><span class="line">42  字节被读取</span><br><span class="line">菜鸟教程官网地址：www.runoob.com</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h2><ul>
<li>语法<br>以下为异步模式下关闭文件的语法格式：<br><code>fs.close(fd, callback)</code><br>该方法使用了文件描述符来读取文件。</li>
<li>参数<br>参数使用说明如下：</li>
<li><em>fd*</em> - 通过 fs.open() 方法返回的文件描述符。</li>
<li><em>callback*</em> - 回调函数，没有参数。</li>
<li>实例<br>input.txt 文件内容为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">菜鸟教程官网地址：www.runoob.com</span><br></pre></td></tr></table></figure>
接下来我们创建 file.js 文件，代码如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line">var buf &#x3D; new Buffer.alloc(1024);</span><br><span class="line"></span><br><span class="line">console.log(&quot;准备打开文件！&quot;);</span><br><span class="line">fs.open(&#39;input.txt&#39;, &#39;r+&#39;, function(err, fd) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;文件打开成功！&quot;);</span><br><span class="line">   console.log(&quot;准备读取文件！&quot;);</span><br><span class="line">   fs.read(fd, buf, 0, buf.length, 0, function(err, bytes)&#123;</span><br><span class="line">      if (err)&#123;</span><br><span class="line">         console.log(err);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 仅输出读取的字节</span><br><span class="line">      if(bytes &gt; 0)&#123;</span><br><span class="line">         console.log(buf.slice(0, bytes).toString());</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      &#x2F;&#x2F; 关闭文件</span><br><span class="line">      fs.close(fd, function(err)&#123;</span><br><span class="line">         if (err)&#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">         &#125; </span><br><span class="line">         console.log(&quot;文件关闭成功&quot;);</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
以上代码执行结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">准备打开文件！</span><br><span class="line">文件打开成功！</span><br><span class="line">准备读取文件！</span><br><span class="line">菜鸟教程官网地址：www.runoob.com</span><br><span class="line">文件关闭成功</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="截取文件"><a href="#截取文件" class="headerlink" title="截取文件"></a>截取文件</h2><ul>
<li>语法<br>以下为异步模式下截取文件的语法格式：<br><code>fs.ftruncate(fd, len, callback)</code><br>该方法使用了文件描述符来读取文件。</li>
<li>参数<br>参数使用说明如下：</li>
<li><em>fd*</em> - 通过 fs.open() 方法返回的文件描述符。</li>
<li><em>len*</em> - 文件内容截取的长度。</li>
<li><em>callback*</em> - 回调函数，没有参数。</li>
<li>实例<br>input.txt 文件内容为：<br><code>site:www.runoob.com</code><br>接下来我们创建 file.js 文件，代码如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line">var buf &#x3D; new Buffer.alloc(1024);</span><br><span class="line"></span><br><span class="line">console.log(&quot;准备打开文件！&quot;);</span><br><span class="line">fs.open(&#39;input.txt&#39;, &#39;r+&#39;, function(err, fd) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;文件打开成功！&quot;);</span><br><span class="line">   console.log(&quot;截取10字节内的文件内容，超出部分将被去除。&quot;);</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 截取文件</span><br><span class="line">   fs.ftruncate(fd, 10, function(err)&#123;</span><br><span class="line">      if (err)&#123;</span><br><span class="line">         console.log(err);</span><br><span class="line">      &#125; </span><br><span class="line">      console.log(&quot;文件截取成功。&quot;);</span><br><span class="line">      console.log(&quot;读取相同的文件&quot;); </span><br><span class="line">      fs.read(fd, buf, 0, buf.length, 0, function(err, bytes)&#123;</span><br><span class="line">         if (err)&#123;</span><br><span class="line">            console.log(err);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 仅输出读取的字节</span><br><span class="line">         if(bytes &gt; 0)&#123;</span><br><span class="line">            console.log(buf.slice(0, bytes).toString());</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         &#x2F;&#x2F; 关闭文件</span><br><span class="line">         fs.close(fd, function(err)&#123;</span><br><span class="line">            if (err)&#123;</span><br><span class="line">               console.log(err);</span><br><span class="line">            &#125; </span><br><span class="line">            console.log(&quot;文件关闭成功！&quot;);</span><br><span class="line">         &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
以上代码执行结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">准备打开文件！</span><br><span class="line">文件打开成功！</span><br><span class="line">截取10字节内的文件内容，超出部分将被去除。</span><br><span class="line">文件截取成功。</span><br><span class="line">读取相同的文件</span><br><span class="line">site:www.r</span><br><span class="line">文件关闭成功</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h2><ul>
<li>语法<br>以下为删除文件的语法格式：<br><code>fs.unlink(path, callback)</code></li>
<li>参数<br>参数使用说明如下：</li>
<li><em>path*</em> - 文件路径。</li>
<li><em>callback*</em> - 回调函数，没有参数。</li>
<li>实例<br>input.txt 文件内容为：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">site:www.runoob.com</span><br></pre></td></tr></table></figure>
接下来我们创建 file.js 文件，代码如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;准备删除文件！&quot;);</span><br><span class="line">fs.unlink(&#39;input.txt&#39;, function(err) &#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;文件删除成功！&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
以上代码执行结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">准备删除文件！</span><br><span class="line">文件删除成功！</span><br></pre></td></tr></table></figure>
再去查看 input.txt 文件，发现已经不存在了。</li>
</ul>
<h2 id="创建目录"><a href="#创建目录" class="headerlink" title="创建目录"></a>创建目录</h2><ul>
<li>语法<br>以下为创建目录的语法格式：<br><code>fs.mkdir(path[, options], callback)</code></li>
<li>参数<br>参数使用说明如下：</li>
<li><em>path*</em> - 文件路径。</li>
<li><em>options*</em> 参数可以是：<br>   <strong>recursive</strong> - 是否以递归的方式创建目录，默认为 false。<br>   <strong>mode</strong> - 设置目录权限，默认为 0777。</li>
<li><em>callback*</em> - 回调函数，没有参数。</li>
<li>实例<br>接下来我们创建 file.js 文件，代码如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line">&#x2F;&#x2F; tmp 目录必须存在</span><br><span class="line">console.log(&quot;创建目录 &#x2F;tmp&#x2F;test&#x2F;&quot;);</span><br><span class="line">fs.mkdir(&quot;&#x2F;tmp&#x2F;test&#x2F;&quot;,function(err)&#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;目录创建成功。&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
以上代码执行结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">创建目录 &#x2F;tmp&#x2F;test&#x2F;</span><br><span class="line">目录创建成功。</span><br></pre></td></tr></table></figure>
可以添加 recursive: true 参数，不管创建的目录 /tmp 和 /tmp/a 是否存在：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fs.mkdir(&#39;&#x2F;tmp&#x2F;a&#x2F;apple&#39;, &#123; recursive: true &#125;, (err) &#x3D;&gt; &#123;</span><br><span class="line">  if (err) throw err;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="读取目录"><a href="#读取目录" class="headerlink" title="读取目录"></a>读取目录</h2><ul>
<li>语法<br>以下为读取目录的语法格式：<br><code>fs.readdir(path, callback)</code></li>
<li>参数<br>参数使用说明如下：</li>
<li><em>path*</em> - 文件路径。</li>
<li><em>callback*</em> - 回调函数，回调函数带有两个参数err, files，err 为错误信息，files 为目录下的文件数组列表。</li>
<li>实例<br>接下来我们创建 file.js 文件，代码如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line"></span><br><span class="line">console.log(&quot;查看 &#x2F;tmp 目录&quot;);</span><br><span class="line">fs.readdir(&quot;&#x2F;tmp&#x2F;&quot;,function(err, files)&#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   files.forEach( function (file)&#123;</span><br><span class="line">       console.log( file );</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
以上代码执行结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">查看 &#x2F;tmp 目录</span><br><span class="line">input.out</span><br><span class="line">output.out</span><br><span class="line">test</span><br><span class="line">test.txt</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="删除目录"><a href="#删除目录" class="headerlink" title="删除目录"></a>删除目录</h2><ul>
<li>语法<br>以下为删除目录的语法格式：<br><code>fs.rmdir(path, callback)</code></li>
<li>参数<br>参数使用说明如下：</li>
<li><em>path*</em> - 文件路径。</li>
<li><em>callback*</em> - 回调函数，没有参数。</li>
<li>实例<br>接下来我们创建 file.js 文件，代码如下所示：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var fs &#x3D; require(&quot;fs&quot;);</span><br><span class="line">&#x2F;&#x2F; 执行前创建一个空的 &#x2F;tmp&#x2F;test 目录</span><br><span class="line">console.log(&quot;准备删除目录 &#x2F;tmp&#x2F;test&quot;);</span><br><span class="line">fs.rmdir(&quot;&#x2F;tmp&#x2F;test&quot;,function(err)&#123;</span><br><span class="line">   if (err) &#123;</span><br><span class="line">       return console.error(err);</span><br><span class="line">   &#125;</span><br><span class="line">   console.log(&quot;读取 &#x2F;tmp 目录&quot;);</span><br><span class="line">   fs.readdir(&quot;&#x2F;tmp&#x2F;&quot;,function(err, files)&#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">          return console.error(err);</span><br><span class="line">      &#125;</span><br><span class="line">      files.forEach( function (file)&#123;</span><br><span class="line">          console.log( file );</span><br><span class="line">      &#125;);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
以上代码执行结果如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node file.js </span><br><span class="line">准备删除目录 &#x2F;tmp&#x2F;test</span><br><span class="line">读取 &#x2F;tmp 目录</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="文件模块方法参考手册"><a href="#文件模块方法参考手册" class="headerlink" title="文件模块方法参考手册"></a>文件模块方法参考手册</h2><ol>
<li><p>fs.rename(oldPath, newPath, callback)<br>异步 rename().回调函数没有参数，但可能抛出异常。</p>
</li>
<li><p>fs.ftruncate(fd, len, callback)<br>异步 ftruncate().回调函数没有参数，但可能抛出异常。</p>
</li>
<li><p>fs.ftruncateSync(fd, len)<br>同步 ftruncate()</p>
</li>
<li><p>fs.truncate(path, len, callback)<br>异步 truncate().回调函数没有参数，但可能抛出异常。</p>
</li>
<li><p>fs.truncateSync(path, len)<br>同步 truncate()</p>
</li>
<li><p>fs.chown(path, uid, gid, callback)<br>异步 chown().回调函数没有参数，但可能抛出异常。</p>
</li>
<li><p>fs.chownSync(path, uid, gid)<br>同步 chown()</p>
</li>
<li><p>fs.fchown(fd, uid, gid, callback)<br>异步 fchown().回调函数没有参数，但可能抛出异常。</p>
</li>
<li><p>fs.fchownSync(fd, uid, gid)<br>同步 fchown()</p>
</li>
<li><p>fs.lchown(path, uid, gid, callback)<br>异步 lchown().回调函数没有参数，但可能抛出异常。</p>
</li>
<li><p>fs.lchownSync(path, uid, gid)<br>同步 lchown()</p>
</li>
<li><p>fs.chmod(path, mode, callback)<br>异步 chmod().回调函数没有参数，但可能抛出异常。</p>
</li>
<li><p>fs.chmodSync(path, mode)<br>同步 chmod().</p>
</li>
<li><p>fs.fchmod(fd, mode, callback)<br>异步 fchmod().回调函数没有参数，但可能抛出异常。</p>
</li>
<li><p>fs.fchmodSync(fd, mode)<br>同步 fchmod().</p>
</li>
<li><p>fs.lchmod(path, mode, callback)<br>异步 lchmod().回调函数没有参数，但可能抛出异常。Only available on Mac OS X.</p>
</li>
<li><p>fs.lchmodSync(path, mode)<br>同步 lchmod().</p>
</li>
<li><p>fs.stat(path, callback)<br>异步 stat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。</p>
</li>
<li><p>fs.lstat(path, callback)<br>异步 lstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。</p>
</li>
<li><p>fs.fstat(fd, callback)<br>异步 fstat(). 回调函数有两个参数 err, stats，stats 是 fs.Stats 对象。</p>
</li>
<li><p>fs.statSync(path)<br>同步 stat(). 返回 fs.Stats 的实例。</p>
</li>
<li><p>fs.lstatSync(path)<br>同步 lstat(). 返回 fs.Stats 的实例。</p>
</li>
<li><p>fs.fstatSync(fd)<br>同步 fstat(). 返回 fs.Stats 的实例。</p>
</li>
<li><p>fs.link(srcpath, dstpath, callback)<br>异步 link().回调函数没有参数，但可能抛出异常。</p>
</li>
<li><p>fs.linkSync(srcpath, dstpath)<br>同步 link().</p>
</li>
<li><p>fs.symlink(srcpath, dstpath[, type], callback)<br>异步 symlink().回调函数没有参数，但可能抛出异常。 type 参数可以设置为 ‘dir’, ‘file’, 或 ‘junction’ (默认为 ‘file’) 。</p>
</li>
<li><p>fs.symlinkSync(srcpath, dstpath[, type])<br>同步 symlink().</p>
</li>
<li><p>fs.readlink(path, callback)<br>异步 readlink(). 回调函数有两个参数 err, linkString。</p>
</li>
<li><p>fs.realpath(path[, cache], callback)<br>异步 realpath(). 回调函数有两个参数 err, resolvedPath。</p>
</li>
<li><p>fs.realpathSync(path[, cache])<br>同步 realpath()。返回绝对路径。</p>
</li>
<li><p>fs.unlink(path, callback)<br>异步 unlink().回调函数没有参数，但可能抛出异常。</p>
</li>
<li><p>fs.unlinkSync(path)<br>同步 unlink().</p>
</li>
<li><p>fs.rmdir(path, callback)<br>异步 rmdir().回调函数没有参数，但可能抛出异常。</p>
</li>
<li><p>fs.rmdirSync(path)<br>同步 rmdir().</p>
</li>
<li><p>fs.mkdir(path[, mode], callback)<br>S异步 mkdir(2).回调函数没有参数，但可能抛出异常。 访问权限默认为 0777。</p>
</li>
<li><p>fs.mkdirSync(path[, mode])<br>同步 mkdir().</p>
</li>
<li><p>fs.readdir(path, callback)<br>异步 readdir(3). 读取目录的内容。</p>
</li>
<li><p>fs.readdirSync(path)<br>同步 readdir().返回文件数组列表。</p>
</li>
<li><p>fs.close(fd, callback)<br>异步 close().回调函数没有参数，但可能抛出异常。</p>
</li>
<li><p>fs.closeSync(fd)<br>同步 close().</p>
</li>
<li><p>fs.open(path, flags[, mode], callback)<br>异步打开文件。</p>
</li>
<li><p>fs.openSync(path, flags[, mode])<br>同步 version of fs.open().</p>
</li>
<li><p>fs.utimes(path, atime, mtime, callback)</p>
</li>
<li><p>fs.utimesSync(path, atime, mtime)<br>修改文件时间戳，文件通过指定的文件路径。</p>
</li>
<li><p>fs.futimes(fd, atime, mtime, callback)</p>
</li>
<li><p>fs.futimesSync(fd, atime, mtime)<br>修改文件时间戳，通过文件描述符指定。</p>
</li>
<li><p>fs.fsync(fd, callback)<br>异步 fsync.回调函数没有参数，但可能抛出异常。</p>
</li>
<li><p>fs.fsyncSync(fd)<br>同步 fsync.</p>
</li>
<li><p>fs.write(fd, buffer, offset, length[, position], callback)<br>将缓冲区内容写入到通过文件描述符指定的文件。</p>
</li>
<li><p>fs.write(fd, data[, position[, encoding]], callback)<br>通过文件描述符 fd 写入文件内容。</p>
</li>
<li><p>fs.writeSync(fd, buffer, offset, length[, position])<br>同步版的 fs.write()。</p>
</li>
<li><p>fs.writeSync(fd, data[, position[, encoding]])<br>同步版的 fs.write().</p>
</li>
<li><p>fs.read(fd, buffer, offset, length, position, callback)<br>通过文件描述符 fd 读取文件内容。</p>
</li>
<li><p>fs.readSync(fd, buffer, offset, length, position)<br>同步版的 fs.read.</p>
</li>
<li><p>fs.readFile(filename[, options], callback)<br>异步读取文件内容。</p>
</li>
<li><p>fs.readFileSync(filename[, options])</p>
</li>
<li><p>fs.writeFile(filename, data[, options], callback)<br>异步写入文件内容。</p>
</li>
<li><p>fs.writeFileSync(filename, data[, options])<br>同步版的 fs.writeFile。</p>
</li>
<li><p>fs.appendFile(filename, data[, options], callback)<br>异步追加文件内容。</p>
</li>
<li><p>fs.appendFileSync(filename, data[, options])<br>The 同步 version of fs.appendFile.</p>
</li>
<li><p>fs.watchFile(filename[, options], listener)<br>查看文件的修改。</p>
</li>
<li><p>fs.unwatchFile(filename[, listener])<br>停止查看 filename 的修改。</p>
</li>
<li><p>fs.watch(filename[, options][, listener])<br>查看 filename 的修改，filename 可以是文件或目录。返回 fs.FSWatcher 对象。</p>
</li>
<li><p>fs.exists(path, callback)<br>检测给定的路径是否存在。</p>
</li>
<li><p>fs.existsSync(path)<br>同步版的 fs.exists.</p>
</li>
<li><p>fs.access(path[, mode], callback)<br>测试指定路径用户权限。</p>
</li>
<li><p>fs.accessSync(path[, mode])<br>同步版的 fs.access。</p>
</li>
<li><p>fs.createReadStream(path[, options])<br>返回ReadStream 对象。</p>
</li>
<li><p>fs.createWriteStream(path[, options])<br>返回 WriteStream 对象。</p>
</li>
<li><p>fs.symlink(srcpath, dstpath[, type], callback)<br>异步 symlink().回调函数没有参数，但可能抛出异常。</p>
</li>
</ol>
<hr>
<h1 id="Node-js-GET-POST请求"><a href="#Node-js-GET-POST请求" class="headerlink" title="Node.js GET/POST请求"></a>Node.js GET/POST请求</h1><p>在很多场景中，我们的服务器都需要跟用户的浏览器打交道，如表单提交。<br>表单提交到服务器一般都使用 GET/POST 请求。<br>本章节我们将为大家介绍 Node.js GET/POST请求。</p>
<h2 id="获取GET请求内容"><a href="#获取GET请求内容" class="headerlink" title="获取GET请求内容"></a>获取GET请求内容</h2><p>由于GET请求直接被嵌入在路径中，URL是完整的请求路径，包括了?后面的部分，因此你可以手动解析后面的内容作为GET请求的参数。<br>node.js 中 url 模块中的 parse 函数提供了这个功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&#39;http&#39;);</span><br><span class="line">var url &#x3D; require(&#39;url&#39;);</span><br><span class="line">var util &#x3D; require(&#39;util&#39;);</span><br><span class="line"> </span><br><span class="line">http.createServer(function(req, res)&#123;</span><br><span class="line">    res.writeHead(200, &#123;&#39;Content-Type&#39;: &#39;text&#x2F;plain; charset&#x3D;utf-8&#39;&#125;);</span><br><span class="line">    res.end(util.inspect(url.parse(req.url, true)));</span><br><span class="line">&#125;).listen(3000);</span><br></pre></td></tr></table></figure>
<p>在浏览器中访问 <a href="http://localhost:3000/user?name=菜鸟教程&amp;url=www.runoob.com" target="_blank" rel="noopener">http://localhost:3000/user?name=菜鸟教程&amp;url=www.runoob.com</a> 然后查看返回结果:<br><img src="http://www.runoob.com/wp-content/uploads/2014/06/4A1C02B2-2EB8-4976-9F35-F3760713D495.jpg" alt=""></p>
<h3 id="获取-URL-的参数"><a href="#获取-URL-的参数" class="headerlink" title="获取 URL 的参数"></a>获取 URL 的参数</h3><p>我们可以使用 url.parse 方法来解析 URL 中的参数，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&#39;http&#39;);</span><br><span class="line">var url &#x3D; require(&#39;url&#39;);</span><br><span class="line">var util &#x3D; require(&#39;util&#39;);</span><br><span class="line"> </span><br><span class="line">http.createServer(function(req, res)&#123;</span><br><span class="line">    res.writeHead(200, &#123;&#39;Content-Type&#39;: &#39;text&#x2F;plain&#39;&#125;);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 解析 url 参数</span><br><span class="line">    var params &#x3D; url.parse(req.url, true).query;</span><br><span class="line">    res.write(&quot;网站名：&quot; + params.name);</span><br><span class="line">    res.write(&quot;\n&quot;);</span><br><span class="line">    res.write(&quot;网站 URL：&quot; + params.url);</span><br><span class="line">    res.end();</span><br><span class="line"> </span><br><span class="line">&#125;).listen(3000);</span><br></pre></td></tr></table></figure>
<p>在浏览器中访问 <a href="http://localhost:3000/user?name=菜鸟教程&amp;url=www.runoob.com" target="_blank" rel="noopener">http://localhost:3000/user?name=菜鸟教程&amp;url=www.runoob.com</a> 然后查看返回结果:<br><img src="http://www.runoob.com/wp-content/uploads/2014/06/ADF34B0E-6715-41EE-9A88-4BE067100868.jpg" alt=""></p>
<h2 id="获取-POST-请求内容"><a href="#获取-POST-请求内容" class="headerlink" title="获取 POST 请求内容"></a>获取 POST 请求内容</h2><p>POST 请求的内容全部的都在请求体中，http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作。<br>比如上传文件，而很多时候我们可能并不需要理会请求体的内容，恶意的POST请求会大大消耗服务器的资源，所以 node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做。</p>
<figure class="highlight plain"><figcaption><span>基本语法结构说明</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&#39;http&#39;);</span><br><span class="line">var querystring &#x3D; require(&#39;querystring&#39;);</span><br><span class="line"> </span><br><span class="line">http.createServer(function(req, res)&#123;</span><br><span class="line">    &#x2F;&#x2F; 定义了一个post变量，用于暂存请求体的信息</span><br><span class="line">    var post &#x3D; &#39;&#39;;     </span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 通过req的data事件监听函数，每当接受到请求体的数据，就累加到post变量中</span><br><span class="line">    req.on(&#39;data&#39;, function(chunk)&#123;    </span><br><span class="line">        post +&#x3D; chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"> </span><br><span class="line">    &#x2F;&#x2F; 在end事件触发后，通过querystring.parse将post解析为真正的POST请求格式，然后向客户端返回。</span><br><span class="line">    req.on(&#39;end&#39;, function()&#123;    </span><br><span class="line">        post &#x3D; querystring.parse(post);</span><br><span class="line">        res.end(util.inspect(post));</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).listen(3000);</span><br></pre></td></tr></table></figure>
<p>以下实例表单通过 POST 提交并输出数据：</p>
<figure class="highlight plain"><figcaption><span>实例</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&#39;http&#39;);</span><br><span class="line">var querystring &#x3D; require(&#39;querystring&#39;);</span><br><span class="line"> </span><br><span class="line">var postHTML &#x3D; </span><br><span class="line">  &#39;&lt;html&gt;&lt;head&gt;&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;&lt;title&gt;菜鸟教程 Node.js 实例&lt;&#x2F;title&gt;&lt;&#x2F;head&gt;&#39; +</span><br><span class="line">  &#39;&lt;body&gt;&#39; +</span><br><span class="line">  &#39;&lt;form method&#x3D;&quot;post&quot;&gt;&#39; +</span><br><span class="line">  &#39;网站名： &lt;input name&#x3D;&quot;name&quot;&gt;&lt;br&gt;&#39; +</span><br><span class="line">  &#39;网站 URL： &lt;input name&#x3D;&quot;url&quot;&gt;&lt;br&gt;&#39; +</span><br><span class="line">  &#39;&lt;input type&#x3D;&quot;submit&quot;&gt;&#39; +</span><br><span class="line">  &#39;&lt;&#x2F;form&gt;&#39; +</span><br><span class="line">  &#39;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;&#39;;</span><br><span class="line"> </span><br><span class="line">http.createServer(function (req, res) &#123;</span><br><span class="line">  var body &#x3D; &quot;&quot;;</span><br><span class="line">  req.on(&#39;data&#39;, function (chunk) &#123;</span><br><span class="line">    body +&#x3D; chunk;</span><br><span class="line">  &#125;);</span><br><span class="line">  req.on(&#39;end&#39;, function () &#123;</span><br><span class="line">    &#x2F;&#x2F; 解析参数</span><br><span class="line">    body &#x3D; querystring.parse(body);</span><br><span class="line">    &#x2F;&#x2F; 设置响应头部信息及编码</span><br><span class="line">    res.writeHead(200, &#123;&#39;Content-Type&#39;: &#39;text&#x2F;html; charset&#x3D;utf8&#39;&#125;);</span><br><span class="line"> </span><br><span class="line">    if(body.name &amp;&amp; body.url) &#123; &#x2F;&#x2F; 输出提交的数据</span><br><span class="line">        res.write(&quot;网站名：&quot; + body.name);</span><br><span class="line">        res.write(&quot;&lt;br&gt;&quot;);</span><br><span class="line">        res.write(&quot;网站 URL：&quot; + body.url);</span><br><span class="line">    &#125; else &#123;  &#x2F;&#x2F; 输出表单</span><br><span class="line">        res.write(postHTML);</span><br><span class="line">    &#125;</span><br><span class="line">    res.end();</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;).listen(3000);</span><br></pre></td></tr></table></figure>
<p>执行结果 Gif 演示：<br><img src="http://www.runoob.com/wp-content/uploads/2014/06/nodepost.gif" alt=""></p>
<hr>
<h1 id="Node-js-Web-模块"><a href="#Node-js-Web-模块" class="headerlink" title="Node.js Web 模块"></a>Node.js Web 模块</h1><h2 id="使用-Node-创建-Web-服务器"><a href="#使用-Node-创建-Web-服务器" class="headerlink" title="使用 Node 创建 Web 服务器"></a>使用 Node 创建 Web 服务器</h2><p>Node.js 提供了 http 模块，http 模块主要用于搭建 HTTP 服务端和客户端，使用 HTTP 服务器或客户端功能必须调用 http 模块，代码如下：<br><code>var http = require(&#39;http&#39;);</code><br>以下是演示一个最基本的 HTTP 服务器架构(使用 8080 端口)，创建 server.js 文件，代码如下所示：</p>
<figure class="highlight plain"><figcaption><span>server.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&#39;http&#39;);</span><br><span class="line">var fs &#x3D; require(&#39;fs&#39;);</span><br><span class="line">var url &#x3D; require(&#39;url&#39;);</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 创建服务器</span><br><span class="line">http.createServer( function (request, response) &#123;  </span><br><span class="line">   &#x2F;&#x2F; 解析请求，包括文件名</span><br><span class="line">   var pathname &#x3D; url.parse(request.url).pathname;</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 输出请求的文件名</span><br><span class="line">   console.log(&quot;Request for &quot; + pathname + &quot; received.&quot;);</span><br><span class="line">   </span><br><span class="line">   &#x2F;&#x2F; 从文件系统中读取请求的文件内容</span><br><span class="line">   fs.readFile(pathname.substr(1), function (err, data) &#123;</span><br><span class="line">      if (err) &#123;</span><br><span class="line">         console.log(err);</span><br><span class="line">         &#x2F;&#x2F; HTTP 状态码: 404 : NOT FOUND</span><br><span class="line">         &#x2F;&#x2F; Content Type: text&#x2F;plain</span><br><span class="line">         response.writeHead(404, &#123;&#39;Content-Type&#39;: &#39;text&#x2F;html&#39;&#125;);</span><br><span class="line">      &#125;else&#123;             </span><br><span class="line">         &#x2F;&#x2F; HTTP 状态码: 200 : OK</span><br><span class="line">         &#x2F;&#x2F; Content Type: text&#x2F;plain</span><br><span class="line">         response.writeHead(200, &#123;&#39;Content-Type&#39;: &#39;text&#x2F;html&#39;&#125;);    </span><br><span class="line">         </span><br><span class="line">         &#x2F;&#x2F; 响应文件内容</span><br><span class="line">         response.write(data.toString());        </span><br><span class="line">      &#125;</span><br><span class="line">      &#x2F;&#x2F;  发送响应数据</span><br><span class="line">      response.end();</span><br><span class="line">   &#125;);   </span><br><span class="line">&#125;).listen(8080);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 控制台会输出以下信息</span><br><span class="line">console.log(&#39;Server running at http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;&#39;);</span><br></pre></td></tr></table></figure>
<p>接下来我们在该目录下创建一个 index.html 文件，代码如下：</p>
<figure class="highlight plain"><figcaption><span>index.html 文件</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;我的第一个标题&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;p&gt;我的第一个段落。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>执行 server.js 文件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ node server.js</span><br><span class="line">Server running at http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;</span><br></pre></td></tr></table></figure>
<p>接着我们在浏览器中打开地址：<a href="http://127.0.0.1:8080/index.html，显示如下图所示" target="_blank" rel="noopener">http://127.0.0.1:8080/index.html，显示如下图所示</a>:<br><img src="http://www.runoob.com/wp-content/uploads/2015/09/6E0D2A5C-0339-4D61-858D-A4EEB5763D98.jpg" alt=""><br>执行 server.js 的控制台输出信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Server running at http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;</span><br><span class="line">Request for &#x2F;index.html received.     #  客户端请求信息</span><br></pre></td></tr></table></figure>

<h2 id="使用-Node-创建-Web-客户端"><a href="#使用-Node-创建-Web-客户端" class="headerlink" title="使用 Node 创建 Web 客户端"></a>使用 Node 创建 Web 客户端</h2><p>Node 创建 Web 客户端需要引入 http 模块，创建 client.js 文件，代码如下所示：</p>
<figure class="highlight plain"><figcaption><span>client.js</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">var http &#x3D; require(&#39;http&#39;);</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 用于请求的选项</span><br><span class="line">var options &#x3D; &#123;</span><br><span class="line">   host: &#39;localhost&#39;,</span><br><span class="line">   port: &#39;8080&#39;,</span><br><span class="line">   path: &#39;&#x2F;index.html&#39;  </span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 处理响应的回调函数</span><br><span class="line">var callback &#x3D; function(response)&#123;</span><br><span class="line">   &#x2F;&#x2F; 不断更新数据</span><br><span class="line">   var body &#x3D; &#39;&#39;;</span><br><span class="line">   response.on(&#39;data&#39;, function(data) &#123;</span><br><span class="line">      body +&#x3D; data;</span><br><span class="line">   &#125;);</span><br><span class="line">   </span><br><span class="line">   response.on(&#39;end&#39;, function() &#123;</span><br><span class="line">      &#x2F;&#x2F; 数据接收完成</span><br><span class="line">      console.log(body);</span><br><span class="line">   &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 向服务端发送请求</span><br><span class="line">var req &#x3D; http.request(options, callback);</span><br><span class="line">req.end();</span><br></pre></td></tr></table></figure>
<p>新开一个终端，执行 client.js 文件，输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ node  client.js </span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;h1&gt;我的第一个标题&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;p&gt;我的第一个段落。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>
<p>执行 server.js 的控制台输出信息如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Server running at http:&#x2F;&#x2F;127.0.0.1:8080&#x2F;</span><br><span class="line">Request for &#x2F;index.html received.   # 客户端请求信息</span><br></pre></td></tr></table></figure>









      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E7%BD%91%E9%A1%B5/" rel="tag"># 网页</a>
          
            <a href="/tags/nodejs/" rel="tag"># nodejs</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/29/django%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="next" title="django学习笔记">
                <i class="fa fa-chevron-left"></i> django学习笔记
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/02/18/Express%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="prev" title="Express学习笔记">
                Express学习笔记 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
    </div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.gif"
                alt="陈潇" />
            
              <p class="site-author-name" itemprop="name">陈潇</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">49</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/iwannatobehappy" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://845895322@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#简介"><span class="nav-number">1.</span> <span class="nav-text">简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#大览"><span class="nav-number">2.</span> <span class="nav-text">大览</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#helloworld"><span class="nav-number">2.1.</span> <span class="nav-text">helloworld</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#模块系统"><span class="nav-number">3.</span> <span class="nav-text">模块系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述"><span class="nav-number">3.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#NPM-包管理工具"><span class="nav-number">3.2.</span> <span class="nav-text">NPM 包管理工具</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#其他命令"><span class="nav-number">3.2.1.</span> <span class="nav-text">其他命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#淘宝-NPM-镜像"><span class="nav-number">3.2.2.</span> <span class="nav-text">淘宝 NPM 镜像</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#package-json"><span class="nav-number">3.3.</span> <span class="nav-text">package.json</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#版本号解释"><span class="nav-number">3.3.1.</span> <span class="nav-text">版本号解释</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建模块"><span class="nav-number">3.4.</span> <span class="nav-text">创建模块</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Node-js-REPL-交互式解释器"><span class="nav-number">4.</span> <span class="nav-text">Node.js REPL(交互式解释器)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#简单的表达式运算"><span class="nav-number">4.1.</span> <span class="nav-text">简单的表达式运算</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用变量"><span class="nav-number">4.2.</span> <span class="nav-text">使用变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#多行表达式"><span class="nav-number">4.3.</span> <span class="nav-text">多行表达式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#下划线-变量"><span class="nav-number">4.4.</span> <span class="nav-text">下划线(_)变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#REPL-命令"><span class="nav-number">4.5.</span> <span class="nav-text">REPL 命令</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Node-js-回调函数"><span class="nav-number">5.</span> <span class="nav-text">Node.js 回调函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#异步与非阻塞"><span class="nav-number">5.1.</span> <span class="nav-text">异步与非阻塞</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#node-js-回调函数"><span class="nav-number">5.2.</span> <span class="nav-text">node.js 回调函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#阻塞代码实例"><span class="nav-number">5.3.</span> <span class="nav-text">阻塞代码实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#非阻塞代码实例"><span class="nav-number">5.4.</span> <span class="nav-text">非阻塞代码实例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Node-js-事件循环"><span class="nav-number">6.</span> <span class="nav-text">Node.js 事件循环</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#事件驱动程序"><span class="nav-number">6.1.</span> <span class="nav-text">事件驱动程序</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#实例"><span class="nav-number">6.1.1.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Node-应用程序是如何工作的？"><span class="nav-number">6.2.</span> <span class="nav-text">Node 应用程序是如何工作的？</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Node-js-EventEmitter"><span class="nav-number">7.</span> <span class="nav-text">Node.js EventEmitter</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#EventEmitter-类"><span class="nav-number">7.1.</span> <span class="nav-text">EventEmitter 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法"><span class="nav-number">7.2.</span> <span class="nav-text">方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#addListener-event-listener"><span class="nav-number">7.2.1.</span> <span class="nav-text">addListener(event, listener)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#on-event-listener"><span class="nav-number">7.2.2.</span> <span class="nav-text">on(event, listener)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#once-event-listener"><span class="nav-number">7.2.3.</span> <span class="nav-text">once(event, listener)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#removeListener-event-listener"><span class="nav-number">7.2.4.</span> <span class="nav-text">removeListener(event, listener)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#removeAllListeners-event"><span class="nav-number">7.2.5.</span> <span class="nav-text">removeAllListeners([event])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#setMaxListeners-n"><span class="nav-number">7.2.6.</span> <span class="nav-text">setMaxListeners(n)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#listeners-event"><span class="nav-number">7.2.7.</span> <span class="nav-text">listeners(event)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#emit-event-arg1-arg2-…"><span class="nav-number">7.2.8.</span> <span class="nav-text">emit(event, [arg1], [arg2], […])</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#类方法"><span class="nav-number">7.3.</span> <span class="nav-text">类方法</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#listenerCount-emitter-event"><span class="nav-number">7.3.1.</span> <span class="nav-text">listenerCount(emitter, event)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#事件"><span class="nav-number">7.4.</span> <span class="nav-text">事件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#newListener"><span class="nav-number">7.4.1.</span> <span class="nav-text">newListener</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#removeListener"><span class="nav-number">7.4.2.</span> <span class="nav-text">removeListener</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#实例-1"><span class="nav-number">7.5.</span> <span class="nav-text">实例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#error-事件"><span class="nav-number">7.6.</span> <span class="nav-text">error 事件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#继承-EventEmitter"><span class="nav-number">7.7.</span> <span class="nav-text">继承 EventEmitter</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Node-js-Buffer-缓冲区"><span class="nav-number">8.</span> <span class="nav-text">Node.js Buffer(缓冲区)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Buffer-与字符编码"><span class="nav-number">8.1.</span> <span class="nav-text">Buffer 与字符编码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建-Buffer-类"><span class="nav-number">8.2.</span> <span class="nav-text">创建 Buffer 类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写入缓冲区"><span class="nav-number">8.3.</span> <span class="nav-text">写入缓冲区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从缓冲区读取数据"><span class="nav-number">8.4.</span> <span class="nav-text">从缓冲区读取数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#将-Buffer-转换为-JSON-对象"><span class="nav-number">8.5.</span> <span class="nav-text">将 Buffer 转换为 JSON 对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲区合并"><span class="nav-number">8.6.</span> <span class="nav-text">缓冲区合并</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲区比较"><span class="nav-number">8.7.</span> <span class="nav-text">缓冲区比较</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#拷贝缓冲区"><span class="nav-number">8.8.</span> <span class="nav-text">拷贝缓冲区</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲区裁剪"><span class="nav-number">8.9.</span> <span class="nav-text">缓冲区裁剪</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#缓冲区长度"><span class="nav-number">8.10.</span> <span class="nav-text">缓冲区长度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#方法手册"><span class="nav-number">8.11.</span> <span class="nav-text">方法手册</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-length"><span class="nav-number">8.11.1.</span> <span class="nav-text">buf.length</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-write-string-offset-length-encoding"><span class="nav-number">8.11.2.</span> <span class="nav-text">buf.write(string[, offset[, length]][, encoding])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-writeUIntLE-value-offset-byteLength-noAssert"><span class="nav-number">8.11.3.</span> <span class="nav-text">buf.writeUIntLE(value, offset, byteLength[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-writeUIntBE-value-offset-byteLength-noAssert"><span class="nav-number">8.11.4.</span> <span class="nav-text">buf.writeUIntBE(value, offset, byteLength[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-writeIntLE-value-offset-byteLength-noAssert"><span class="nav-number">8.11.5.</span> <span class="nav-text">buf.writeIntLE(value, offset, byteLength[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-writeIntBE-value-offset-byteLength-noAssert"><span class="nav-number">8.11.6.</span> <span class="nav-text">buf.writeIntBE(value, offset, byteLength[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-readUIntLE-offset-byteLength-noAssert"><span class="nav-number">8.11.7.</span> <span class="nav-text">buf.readUIntLE(offset, byteLength[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-readUIntBE-offset-byteLength-noAssert"><span class="nav-number">8.11.8.</span> <span class="nav-text">buf.readUIntBE(offset, byteLength[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-readIntLE-offset-byteLength-noAssert"><span class="nav-number">8.11.9.</span> <span class="nav-text">buf.readIntLE(offset, byteLength[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-readIntBE-offset-byteLength-noAssert"><span class="nav-number">8.11.10.</span> <span class="nav-text">buf.readIntBE(offset, byteLength[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-toString-encoding-start-end"><span class="nav-number">8.11.11.</span> <span class="nav-text">buf.toString([encoding[, start[, end]]])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-toJSON"><span class="nav-number">8.11.12.</span> <span class="nav-text">buf.toJSON()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-index"><span class="nav-number">8.11.13.</span> <span class="nav-text">buf[index]</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-equals-otherBuffer"><span class="nav-number">8.11.14.</span> <span class="nav-text">buf.equals(otherBuffer)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-compare-otherBuffer"><span class="nav-number">8.11.15.</span> <span class="nav-text">buf.compare(otherBuffer)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-copy-targetBuffer-targetStart-sourceStart-sourceEnd"><span class="nav-number">8.11.16.</span> <span class="nav-text">buf.copy(targetBuffer[, targetStart[, sourceStart[, sourceEnd]]])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-slice-start-end"><span class="nav-number">8.11.17.</span> <span class="nav-text">buf.slice([start[, end]])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-readUInt8-offset-noAssert"><span class="nav-number">8.11.18.</span> <span class="nav-text">buf.readUInt8(offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-readUInt16LE-offset-noAssert"><span class="nav-number">8.11.19.</span> <span class="nav-text">buf.readUInt16LE(offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-readUInt16BE-offset-noAssert"><span class="nav-number">8.11.20.</span> <span class="nav-text">buf.readUInt16BE(offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-readUInt32LE-offset-noAssert"><span class="nav-number">8.11.21.</span> <span class="nav-text">buf.readUInt32LE(offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-readUInt32BE-offset-noAssert"><span class="nav-number">8.11.22.</span> <span class="nav-text">buf.readUInt32BE(offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-readInt8-offset-noAssert"><span class="nav-number">8.11.23.</span> <span class="nav-text">buf.readInt8(offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-readInt16LE-offset-noAssert"><span class="nav-number">8.11.24.</span> <span class="nav-text">buf.readInt16LE(offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-readInt16BE-offset-noAssert"><span class="nav-number">8.11.25.</span> <span class="nav-text">buf.readInt16BE(offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-readInt32LE-offset-noAssert"><span class="nav-number">8.11.26.</span> <span class="nav-text">buf.readInt32LE(offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-readInt32BE-offset-noAssert"><span class="nav-number">8.11.27.</span> <span class="nav-text">buf.readInt32BE(offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-readFloatLE-offset-noAssert"><span class="nav-number">8.11.28.</span> <span class="nav-text">buf.readFloatLE(offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-readFloatBE-offset-noAssert"><span class="nav-number">8.11.29.</span> <span class="nav-text">buf.readFloatBE(offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-readDoubleLE-offset-noAssert"><span class="nav-number">8.11.30.</span> <span class="nav-text">buf.readDoubleLE(offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-readDoubleBE-offset-noAssert"><span class="nav-number">8.11.31.</span> <span class="nav-text">buf.readDoubleBE(offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-writeUInt8-value-offset-noAssert"><span class="nav-number">8.11.32.</span> <span class="nav-text">buf.writeUInt8(value, offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-writeUInt16LE-value-offset-noAssert"><span class="nav-number">8.11.33.</span> <span class="nav-text">buf.writeUInt16LE(value, offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-writeUInt16BE-value-offset-noAssert"><span class="nav-number">8.11.34.</span> <span class="nav-text">buf.writeUInt16BE(value, offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-writeUInt32LE-value-offset-noAssert"><span class="nav-number">8.11.35.</span> <span class="nav-text">buf.writeUInt32LE(value, offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-writeUInt32BE-value-offset-noAssert"><span class="nav-number">8.11.36.</span> <span class="nav-text">buf.writeUInt32BE(value, offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-writeInt8-value-offset-noAssert"><span class="nav-number">8.11.37.</span> <span class="nav-text">buf.writeInt8(value, offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-writeInt16LE-value-offset-noAssert"><span class="nav-number">8.11.38.</span> <span class="nav-text">buf.writeInt16LE(value, offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-writeInt16BE-value-offset-noAssert"><span class="nav-number">8.11.39.</span> <span class="nav-text">buf.writeInt16BE(value, offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-writeInt32LE-value-offset-noAssert"><span class="nav-number">8.11.40.</span> <span class="nav-text">buf.writeInt32LE(value, offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-writeInt32BE-value-offset-noAssert"><span class="nav-number">8.11.41.</span> <span class="nav-text">buf.writeInt32BE(value, offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-writeFloatLE-value-offset-noAssert"><span class="nav-number">8.11.42.</span> <span class="nav-text">buf.writeFloatLE(value, offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-writeFloatBE-value-offset-noAssert"><span class="nav-number">8.11.43.</span> <span class="nav-text">buf.writeFloatBE(value, offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-writeDoubleLE-value-offset-noAssert"><span class="nav-number">8.11.44.</span> <span class="nav-text">buf.writeDoubleLE(value, offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-writeDoubleBE-value-offset-noAssert"><span class="nav-number">8.11.45.</span> <span class="nav-text">buf.writeDoubleBE(value, offset[, noAssert])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#buf-fill-value-offset-end"><span class="nav-number">8.11.46.</span> <span class="nav-text">buf.fill(value[, offset][, end])</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Node-js-Stream-流"><span class="nav-number">9.</span> <span class="nav-text">Node.js Stream(流)</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-1"><span class="nav-number">9.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#从流中读取数据"><span class="nav-number">9.2.</span> <span class="nav-text">从流中读取数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写入流"><span class="nav-number">9.3.</span> <span class="nav-text">写入流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#管道流"><span class="nav-number">9.4.</span> <span class="nav-text">管道流</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#链式流"><span class="nav-number">9.5.</span> <span class="nav-text">链式流</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Node-js-函数"><span class="nav-number">10.</span> <span class="nav-text">Node.js 函数</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-2"><span class="nav-number">10.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#匿名函数"><span class="nav-number">10.2.</span> <span class="nav-text">匿名函数</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Node-js-路由"><span class="nav-number">11.</span> <span class="nav-text">Node.js 路由</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Node-js-全局对象"><span class="nav-number">12.</span> <span class="nav-text">Node.js 全局对象</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#概述-3"><span class="nav-number">12.1.</span> <span class="nav-text">概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#全局对象与全局变量"><span class="nav-number">12.2.</span> <span class="nav-text">全局对象与全局变量</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#filename"><span class="nav-number">12.3.</span> <span class="nav-text">__filename</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#dirname"><span class="nav-number">12.4.</span> <span class="nav-text">__dirname</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setTimeout-cb-ms"><span class="nav-number">12.5.</span> <span class="nav-text">setTimeout(cb, ms)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clearTimeout-t"><span class="nav-number">12.6.</span> <span class="nav-text">clearTimeout(t)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#setInterval-cb-ms"><span class="nav-number">12.7.</span> <span class="nav-text">setInterval(cb, ms)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#console"><span class="nav-number">12.8.</span> <span class="nav-text">console</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#console-log-data-…"><span class="nav-number">12.8.1.</span> <span class="nav-text">console.log([data][, …])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-info-data-…"><span class="nav-number">12.8.2.</span> <span class="nav-text">console.info([data][, …])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-error-data-…"><span class="nav-number">12.8.3.</span> <span class="nav-text">console.error([data][, …])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-warn-data-…"><span class="nav-number">12.8.4.</span> <span class="nav-text">console.warn([data][, …])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-dir-obj-options"><span class="nav-number">12.8.5.</span> <span class="nav-text">console.dir(obj[, options])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-time-label"><span class="nav-number">12.8.6.</span> <span class="nav-text">console.time(label)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-timeEnd-label"><span class="nav-number">12.8.7.</span> <span class="nav-text">console.timeEnd(label)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-trace-message-…"><span class="nav-number">12.8.8.</span> <span class="nav-text">console.trace(message[, …])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#console-assert-value-message-…"><span class="nav-number">12.8.9.</span> <span class="nav-text">console.assert(value[, message][, …])</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#实例-2"><span class="nav-number">12.8.10.</span> <span class="nav-text">实例</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#process"><span class="nav-number">12.9.</span> <span class="nav-text">process</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#退出状态码"><span class="nav-number">12.9.1.</span> <span class="nav-text">退出状态码</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Process-属性"><span class="nav-number">12.9.2.</span> <span class="nav-text">Process 属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#方法参考手册"><span class="nav-number">12.9.3.</span> <span class="nav-text">方法参考手册</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Node-js-util模块"><span class="nav-number">13.</span> <span class="nav-text">Node.js util模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#util-inherits"><span class="nav-number">13.1.</span> <span class="nav-text">util.inherits</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#util-inspect"><span class="nav-number">13.2.</span> <span class="nav-text">util.inspect</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#util-isArray-object"><span class="nav-number">13.3.</span> <span class="nav-text">util.isArray(object)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#util-isRegExp-object"><span class="nav-number">13.4.</span> <span class="nav-text">util.isRegExp(object)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#util-isDate-object"><span class="nav-number">13.5.</span> <span class="nav-text">util.isDate(object)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#util-isError-object"><span class="nav-number">13.6.</span> <span class="nav-text">util.isError(object)</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Node-js-文件系统"><span class="nav-number">14.</span> <span class="nav-text">Node.js 文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#异步和同步"><span class="nav-number">14.1.</span> <span class="nav-text">异步和同步</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#打开文件"><span class="nav-number">14.2.</span> <span class="nav-text">打开文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取文件信息"><span class="nav-number">14.3.</span> <span class="nav-text">获取文件信息</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#写入文件"><span class="nav-number">14.4.</span> <span class="nav-text">写入文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读取文件"><span class="nav-number">14.5.</span> <span class="nav-text">读取文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#关闭文件"><span class="nav-number">14.6.</span> <span class="nav-text">关闭文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#截取文件"><span class="nav-number">14.7.</span> <span class="nav-text">截取文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除文件"><span class="nav-number">14.8.</span> <span class="nav-text">删除文件</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建目录"><span class="nav-number">14.9.</span> <span class="nav-text">创建目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#读取目录"><span class="nav-number">14.10.</span> <span class="nav-text">读取目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#删除目录"><span class="nav-number">14.11.</span> <span class="nav-text">删除目录</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#文件模块方法参考手册"><span class="nav-number">14.12.</span> <span class="nav-text">文件模块方法参考手册</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Node-js-GET-POST请求"><span class="nav-number">15.</span> <span class="nav-text">Node.js GET&#x2F;POST请求</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#获取GET请求内容"><span class="nav-number">15.1.</span> <span class="nav-text">获取GET请求内容</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#获取-URL-的参数"><span class="nav-number">15.1.1.</span> <span class="nav-text">获取 URL 的参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#获取-POST-请求内容"><span class="nav-number">15.2.</span> <span class="nav-text">获取 POST 请求内容</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Node-js-Web-模块"><span class="nav-number">16.</span> <span class="nav-text">Node.js Web 模块</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-Node-创建-Web-服务器"><span class="nav-number">16.1.</span> <span class="nav-text">使用 Node 创建 Web 服务器</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用-Node-创建-Web-客户端"><span class="nav-number">16.2.</span> <span class="nav-text">使用 Node 创建 Web 客户端</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">陈潇</span>

  
</div>









        
<div class="busuanzi-count">
  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  










  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: true,
        notify: true,
        appId: 'oXGA1XzMIhhs9x4yNbf1DOge-gzGzoHsz',
        appKey: 'JYRNnDQ1kh2RA7V2MYsSnRVR',
        placeholder: 'Just go go',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
